-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implements EIP-712: Typed structured data hashing and signing
--   
--   Please see the README on GitHub at
--   <a>https://github.com/fullstack-development/sign-typed-data#readme</a>
@package sign-typed-data
@version 0.1.0.0


-- | This module defines conditionally present polymorphic values. Unlike
--   Prelude's <a>Maybe</a>, the condition is given at the type level. If
--   the value is present, it can be of any type, but it must support the
--   given constraint.
--   
--   In the <tt>sign-typed-data</tt> library, it's used for the fields of
--   <a>EIP712Domain</a>: depending on the application, some fields may be
--   absent, and those that are present might use an application-specific
--   representation, provided that there is a way to encode it into a
--   Solidity object.
--   
--   The <tt>S</tt> letter in this module stands for "singleton", the same
--   as in <a>SNat</a>, <a>SChar</a> etc.
--   
--   The <tt>C</tt> letter stands for "constrained", and refers to the fact
--   that a non-empty type must support the given constraint.
--   
--   The <tt>F</tt> letter in <a>FMaybe</a> simply means "type family" (as
--   opposed to a GADT or a normal data).
module Data.SignTyped.Type.SCMaybe

-- | A singleton marker for a constrained type-level <a>Maybe</a>.
--   
--   An explicit forall on the <tt>SCJust</tt> constructor allows the
--   existential <tt>a</tt> to be pattern-matched with a type-application
--   pattern, for example:
--   
--   <pre>
--   mbNatVal :: SCMaybe KnownNat mbx -&gt; Maybe Integer
--   mbNatVal SCNothing = Nothing
--   mbNatVal (SCJust @x) = Just (<a>natVal</a> @x undefined)
--   
--   </pre>
data SCMaybe (c :: k -> Constraint) (m :: Maybe k)
[SCNothing] :: SCMaybe c 'Nothing
[SCJust] :: forall a c. c a => SCMaybe c ('Just a)

-- | A class to automatically produce <a>SCMaybe</a>s .
class KnownCMaybe c m
cmaybeSing :: KnownCMaybe c m => SCMaybe c m

-- | A destructor for a context-provided <a>SCMaybe</a>, analogous to
--   <a>maybe</a>, <a>either</a> and <a>bool</a>.
withCMaybe :: forall c m r. KnownCMaybe c m => (m ~ 'Nothing => r) -> (forall a. (m ~ 'Just a, c a) => r) -> r

-- | The type family for a conditionally present value.
data family FMaybe (m :: Maybe Type) :: Type

-- | A destructor for an <a>FMaybe</a>, which uses a <a>KnownCMaybe</a>
--   from the context to determine the actual state of the value (present
--   or absent) and retrieve the required constraint in the present case.
fmaybe :: forall c m r. KnownCMaybe c m => (m ~ 'Nothing => r) -> (forall a. (m ~ 'Just a, c a) => a -> r) -> FMaybe m -> r
instance Data.SignTyped.Type.SCMaybe.KnownCMaybe GHC.Show.Show m => GHC.Show.Show (Data.SignTyped.Type.SCMaybe.FMaybe m)
instance forall k (c :: k -> GHC.Types.Constraint). Data.SignTyped.Type.SCMaybe.KnownCMaybe c 'GHC.Maybe.Nothing
instance forall a1 (c :: a1 -> GHC.Types.Constraint) (a2 :: a1). c a2 => Data.SignTyped.Type.SCMaybe.KnownCMaybe c ('GHC.Maybe.Just a2)

module Data.SignTyped.Type.TestOrdering
class TestEquality f => TestOrdering f
testOrdering :: TestOrdering f => f a -> f b -> OrderingI a b

-- | Ordering data type for type literals that provides proof of their
--   ordering.
data () => OrderingI (a :: k) (b :: k)
[LTI] :: forall {k} (a :: k) (b :: k). Compare a b ~ 'LT => OrderingI a b
[EQI] :: forall {k} (a :: k). Compare a a ~ 'EQ => OrderingI a a
[GTI] :: forall {k} (a :: k) (b :: k). Compare a b ~ 'GT => OrderingI a b

-- | This typeclass declares that a type constructor produces singletons.
--   That is, for each possible type argument <tt>a</tt>, there is at most
--   one possible object of type <tt>f a</tt>.
--   
--   In other words, the instances of this class must satisfy the law:
--   
--   <pre>
--   testOrdering (fa :: f a) (fb :: f b) == EQI    ===&gt;    a !~ b
--   </pre>
--   
--   Examples of good instances of this class are the singletons from
--   <a>GHC.TypeLits</a>, and also <a>TypeRep</a> and <a>SName</a>.
--   
--   There are no additional methods to implement in this class, it is only
--   used as a marker.
class (TestOrdering f) => SingletonConstructor f
instance Data.SignTyped.Type.TestOrdering.SingletonConstructor Data.Typeable.Internal.TypeRep
instance Data.SignTyped.Type.TestOrdering.TestOrdering Data.Typeable.Internal.TypeRep

module Data.SignTyped.Type.Some

-- | A wrapper for existential quantification.
--   
--   Semantically, it's definition is:
--   
--   <pre>
--   data Some (f :: k -&gt; Type) = forall (a :: k). Some (f a)
--   
--   </pre>
--   
--   It's primarily intended to be used with marker GADTs and singleton
--   types, such as <a>SName</a>.
data Some f
pattern Some :: forall f. () => forall t. () => f t -> Some f
usingSome :: (forall t. f t -> r) -> Some f -> r
withSome :: Some f -> (forall t. f t -> r) -> r
instance forall k (f :: k -> *). (forall (t :: k). GHC.Show.Show (f t)) => GHC.Show.Show (Data.SignTyped.Type.Some.Some f)
instance forall k (f :: k -> *). Data.Type.Equality.TestEquality f => GHC.Classes.Eq (Data.SignTyped.Type.Some.Some f)
instance forall k (f :: k -> *). Data.SignTyped.Type.TestOrdering.TestOrdering f => GHC.Classes.Ord (Data.SignTyped.Type.Some.Some f)

module Data.SignTyped.Type.HList

-- | A heterogeneous list.
--   
--   The first parameter is a unary type constructor, which is applied to
--   each of the elements of the second parameter to obtain the full type
--   of each of the <a>HList</a>'s elements.
--   
--   For example, a value of type <tt>HList f '[t1, t2, t3]</tt> contains
--   three objects of types <tt>(f t1, f t2, f t3)</tt>.
data HList f ts
[:/] :: f t -> HList f rest -> HList f (t ': rest)
[HEnd] :: HList f '[]
infixr 4 :/

-- | Heterogeneous <a>map</a>. The mapping function is a natural
--   transformation.
--   
--   For example:
--   
--   <pre>
--     hmap
--         (maybe (Left "no value") Right
--             :: forall t. Maybe t -&gt; Either String t)
--         (Just 10 :/ Just "text"  :/ Nothing @Float  :/ HEnd
--             :: HList Maybe '[Int, String, Float])
--   ==
--         Right 10 :/ Right "text" :/ Left "no value" :/ HEnd
--             :: HList (Either String) '[Int, String, Float]
--   
--   
--   </pre>
hmap :: (forall t. f t -> g t) -> HList f ts -> HList g ts

-- | Heterogeneous <a>traverse</a>.
--   
--   For example:
--   
--   <pre>
--     htraverse
--         (maybe ([Left "no value"]) (\x -&gt; [Left "removed", Right x])
--             :: forall t. Maybe t -&gt; [Either String t])
--         (Just 10         :/ Just "text"    :/ Nothing @Float  :/ HEnd
--             :: HList Maybe '[Int, String, Float])
--   ==
--         [ Left "removed" :/ Left "removed" :/ Left "no value" :/ HEnd
--         , Left "removed" :/ Right "text"   :/ Left "no value" :/ HEnd
--         , Right 10       :/ Left "removed" :/ Left "no value" :/ HEnd
--         , Right 10       :/ Right "text"   :/ Left "no value" :/ HEnd
--         ]
--             :: [HList (Either String) '[Int, String, Float]]
--   
--   
--   </pre>
htraverse :: Applicative m => (forall t. f t -> m (g t)) -> HList f ts -> m (HList g ts)

-- | Heterogeneous <a>foldr</a>.
--   
--   For example:
--   
--   <pre>
--     hfoldr
--         (maybe ("n" ++) (\_ -&gt; ("j" ++))
--             :: forall t. Maybe t -&gt; String -&gt; String)
--         ""
--         (Just 10 :/ Just "text"  :/ Nothing @Float  :/ HEnd
--             :: HList Maybe '[Int, String, Float])
--   ==
--         "jjn"
--   
--   
--   </pre>
hfoldr :: (forall t. f t -> r -> r) -> r -> HList f ts -> r

-- | Heterogeneous <a>foldMap</a>.
hfoldMap :: Monoid m => (forall t. f t -> m) -> HList f ts -> m

-- | Heterogeneous <a>zip</a>.
--   
--   For example:
--   
--   <pre>
--     hzip
--         (Just 10         :/ Just "text"    :/ Nothing         :/ HEnd
--             :: HList Maybe '[Int, String, Float])
--         (Const "a"       :/ Const "b"      :/ Const "c"       :/ HEnd
--             :: HList (Const String) '[Int, String, Float])
--   ==
--         Pair (Just 10) (Const "a") :/ Pair (Just "text") (Const "b") :/ Pair Nothing (Const "c") :/ HEnd
--             :: HList (Product Maybe (Const String)) '[Int, String, Float]
--   
--   
--   </pre>
hzip :: HList f ts -> HList g ts -> HList (Product f g) ts

-- | Heterogeneous <a>zipWith</a>.
--   
--   For example:
--   
--   <pre>
--     hzipWith
--         ((\ma eb -&gt; maybeToList ma &lt;&gt; rightToList eb)
--             :: forall t. Maybe t -&gt; Either () t -&gt; [t])
--         (Just 10         :/ Just "text"    :/ Nothing         :/ HEnd
--             :: HList Maybe '[Int, String, Float])
--         (Right 20        :/ Left ()        :/ Right 34.5      :/ HEnd
--             :: HList (Either ()) '[Int, String, Float])
--   ==
--         [10, 20] :/ ["text"] :/ [34.5] :/ HEnd
--             :: HList [] '[Int, String, Float]
--   
--   
--   </pre>
hzipWith :: (forall t. f t -> g t -> h t) -> HList f ts -> HList g ts -> HList h ts

-- | Convert an <a>HList</a> of <a>Const</a> into a normal list.
htoList :: HList (Const a) ts -> [a]

-- | Convert a normal list into an <a>HList</a> of <a>Const</a>.
hfromList :: [a] -> Some (HList (Const a))

-- | Convert a normal list of <a>Some</a>s into an <a>HList</a>.
--   
--   The name refers to the fact that, similar to <a>sequenceA</a>, the
--   effect of this function can be seen as a transposition of containers.
hsequenceSome :: [Some f] -> Some (HList f)

-- | Lifted product of functors.
data () => Product (f :: k -> Type) (g :: k -> Type) (a :: k)
Pair :: f a -> g a -> Product (f :: k -> Type) (g :: k -> Type) (a :: k)
instance forall k (f :: k -> *) (ts :: [k]). (forall (t :: k). GHC.Show.Show (f t)) => GHC.Show.Show (Data.SignTyped.Type.HList.HList f ts)
instance forall k (f :: k -> *). GHC.Base.Semigroup (Data.SignTyped.Type.Some.Some (Data.SignTyped.Type.HList.HList f))
instance forall k (f :: k -> *). GHC.Base.Monoid (Data.SignTyped.Type.Some.Some (Data.SignTyped.Type.HList.HList f))
instance forall k (f :: k -> *). Data.Type.Equality.TestEquality f => Data.Type.Equality.TestEquality (Data.SignTyped.Type.HList.HList f)


-- | Singleton type for names that use <a>Text</a> for representation, in
--   the style of <a>GHC.TypeLits</a>.
module Data.SignTyped.Type.SName

-- | Singleton for a specific name.
--   
--   To create a known <a>SName</a> constant, use <tt><a>SName</a>
--   @"str"</tt> or <tt><a>nameSing</a> @"str"</tt>.
--   
--   To create an <a>SName</a> from a run-time value, use
--   <a>withSomeSName</a>.
--   
--   To obtain the value inside, use <a>fromSName</a>.
data SName (sym :: Symbol)

-- | An explicitly bidirectional pattern synonym that converts between
--   <a>SName</a> values and <a>KnownName</a> constraints.
pattern SName :: forall sym. () => KnownName sym => SName sym

-- | A class for known names. Any known <a>Symbol</a> can be converted to a
--   name.
class KnownName sym

-- | The singleton for the name.
nameSing :: KnownName sym => SName sym

-- | Convert a singleton into a typeclass instance.
--   
--   In other words, use an <a>SName</a> value as material evidence of a
--   <a>KnownName</a>.
withSName :: forall sym r. SName sym -> (KnownName sym => r) -> r

-- | Convert an arbitrary text into an <a>SName</a>.
withSomeSName :: Text -> (forall sym. SName sym -> r) -> r

-- | Extract the text value from an <a>SName</a>.
fromSName :: SName sym -> Text

-- | Construct an <a>SName</a> from an arbitrary text.
toSomeSName :: Text -> Some SName

-- | (Kind) This is the kind of type-level symbols. Declared here because
--   class IP needs it
data () => Symbol
instance GHC.TypeLits.KnownSymbol sym => Data.SignTyped.Type.SName.KnownName sym
instance GHC.Show.Show (Data.SignTyped.Type.SName.SName sym)
instance Data.Type.Equality.TestEquality Data.SignTyped.Type.SName.SName
instance Data.SignTyped.Type.TestOrdering.TestOrdering Data.SignTyped.Type.SName.SName
instance Data.SignTyped.Type.TestOrdering.SingletonConstructor Data.SignTyped.Type.SName.SName


-- | This module defines a singleton heterogeneous map.
--   
--   This map provides a mapping that exists on both type-level and
--   value-level. The keys of the map are singletons, where each distinct
--   value has its own type marker. The values are arbitrary GADTs that use
--   the type parameter as a marker. For each mapping from a key object and
--   a value object, there is a corresponding mapping from the key's to the
--   value's type markers inside the map's state token.
--   
--   The state token itself is not constructive, it has no direct
--   representation in the Haskell's type system. Instead, it is being kept
--   as an abstract existential, which is consistently the same for the
--   same object, but distinct for any two non-equivalent objects. The
--   presence of a particular mapping inside the state token is asserted
--   axiomatically by the <a>HMap</a>-operating functions.
--   
--   Whenever a new <a>HMap</a> object is created, it is wrapped in a
--   <a>Some</a>. This effectively makes GHC spawn a new existential type
--   for each such creation.
module Data.SignTyped.Type.HMap

-- | A kind for state tokens of <a>HMap</a>s.
data TMap kk kv

-- | A type family that represents a lookup result within a specific state
--   token.
--   
--   There is no constructive definition for this type family, its
--   instances are produced axiomatically by <a>HMap</a>'s functions.
type family Lookup k ms

-- | A singleton heterogeneous map.
--   
--   The last parameter is a type-level token corresponding to the map's
--   value.
data HMap kf vf s
emptyHMap :: Some (HMap kf vf)
singletonHMap :: SingletonConstructor kf => kf kt -> vf vt -> Some (HMap kf vf)
unionHMapWithKey :: SingletonConstructor kf => (Some kf -> Some vf -> Some vf -> Some vf) -> Some (HMap kf vf) -> Some (HMap kf vf) -> Some (HMap kf vf)
lookupHMap :: forall kf kt vf s. SingletonConstructor kf => kf kt -> HMap kf vf s -> Maybe (vf (Lookup kt s))
foldMapHMapWithKey :: Monoid m => (forall kt. kf kt -> vf (Lookup kt s) -> m) -> HMap kf vf s -> m
foldrHMapWithKey :: (forall kt. kf kt -> vf (Lookup kt s) -> r -> r) -> r -> HMap kf vf s -> r

-- | A wrapper for existential quantification.
--   
--   Semantically, it's definition is:
--   
--   <pre>
--   data Some (f :: k -&gt; Type) = forall (a :: k). Some (f a)
--   
--   </pre>
--   
--   It's primarily intended to be used with marker GADTs and singleton
--   types, such as <a>SName</a>.
data Some f
pattern Some :: forall f. () => forall t. () => f t -> Some f
instance forall kk kv (kf :: kk -> *) (vf :: kv -> *) (s :: Data.SignTyped.Type.HMap.TMap kk kv). (forall (kt :: kk). GHC.Show.Show (kf kt), forall (vt :: kv). GHC.Show.Show (vf vt)) => GHC.Show.Show (Data.SignTyped.Type.HMap.HMap kf vf s)
instance forall kk kv (kf :: kk -> *) (vf :: kv -> *). (Data.Type.Equality.TestEquality kf, Data.Type.Equality.TestEquality vf) => Data.Type.Equality.TestEquality (Data.SignTyped.Type.HMap.HMap kf vf)
instance forall kk kv (kf :: kk -> *) (vf :: kv -> *). (Data.SignTyped.Type.TestOrdering.SingletonConstructor kf, forall (kt :: kk). GHC.Show.Show (kf kt)) => GHC.Base.Semigroup (Data.SignTyped.Type.Some.Some (Data.SignTyped.Type.HMap.HMap kf vf))
instance forall kk kv (kf :: kk -> *) (vf :: kv -> *). (Data.SignTyped.Type.TestOrdering.SingletonConstructor kf, forall (kt :: kk). GHC.Show.Show (kf kt)) => GHC.Base.Monoid (Data.SignTyped.Type.Some.Some (Data.SignTyped.Type.HMap.HMap kf vf))


-- | An assortment of utility functions that are used across other modules.
module Data.SignTyped.Util

-- | Take <a>KnownSymbol</a> value as a <a>Text</a>.
symbolText :: forall (s :: Symbol). KnownSymbol s => Text

-- | <tt>keccak256</tt> hash of a bytestring, as a bytestring.
--   
--   This is the main hashing function used in Ethereum.
keccak256 :: ByteString -> ByteString

-- | Serialize an integer into a 32-byte big-endian 2's complement
--   bytestring.
--   
--   <pre>
--   integer256 0      = unhex "0x0000000000000000000000000000000000000000000000000000000000000000"
--   integer256 1      = unhex "0x0000000000000000000000000000000000000000000000000000000000000001"
--   integer256 100    = unhex "0x0000000000000000000000000000000000000000000000000000000000000064"
--   integer256 256    = unhex "0x0000000000000000000000000000000000000000000000000000000000000100"
--   integer256 (-1)   = unhex "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
--   integer256 (-256) = unhex "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00"
--   
--   </pre>
integer256 :: Integer -> ByteString

-- | Try to parse the string as an integer.
--   
--   For simplicity, this re-uses the <a>Read</a> instance of
--   <a>Integer</a>, which is quite permissive. For example, all of these
--   strings are accepted as valid representations of the number (-10):
--   
--   <pre>
--   "-10"
--   "-0xa"
--   "-0o12"
--   "   -   10   "
--   "\n\r\t\v\f   -10   "
--   "(((-10)))"
--   
--   </pre>
--   
--   This function is used to parse <tt>intN</tt> and <tt>uintN</tt> values
--   from JSON, so that other programs where native JSON integers are
--   limited by a relatively small number of bits could still produce JSONs
--   with large integers by encoding them in hexadecimal and stringifying.
readNumber :: Text -> Maybe Integer

-- | Try to parse the string as an address, while also verifying the casing
--   of its letter digits to be the correct ERC-55 checksum.
--   
--   This function is used to parse <tt>address</tt> values.
readChecksumAddress :: Text -> Maybe ByteString

-- | Try to parse the string as a potentially hex-encoded string. More
--   specifically, if the input string starts with <tt>0x</tt> or
--   <tt>0X</tt>, it is parsed as a hex-encoded bytestring and then parsed
--   from UTF-8. Otherwise, it is simply interpreted as a literal string.
--   
--   <pre>
--   readSafeTextString "" = Just ""
--   readSafeTextString "Some text" = Just "Some text"
--   readSafeTextString "0x" = Just ""
--   readSafeTextString "0x6f746865722074657874" = Just "other text"
--   readSafeTextString "0x3078" = Just "0x"
--   readSafeTextString "0xf09fa494" = Just "129300"
--   readSafeTextString "0xff" = Nothing -- due to being invalid utf-8
--   
--   </pre>
--   
--   This function is used to parse <tt>string</tt> values.
readSafeTextString :: Text -> Maybe Text

-- | Try to parse the string as a hex-encoded bytestring.
--   
--   This function is used to parse <tt>bytesN</tt> and <tt>bytes</tt>
--   values.
readHexBytes :: Text -> Maybe ByteString

-- | Encode an address in hexadecimal, while also applying the ERC-55
--   mixed-case checksumming.
--   
--   This function is used to serialize <tt>address</tt> values.
encodeChecksumAddress :: ByteString -> Text

-- | Encode a text string in such a way that it can later be parsed
--   unambiguously. If the input string starts with <tt>0x</tt> or
--   <tt>0X</tt>, it will be hex-encoded, otherwise the bytes are UTF-8
--   decoded and simply output literally.
--   
--   <pre>
--   encodeSafeTextString "" = ""
--   encodeSafeTextString "Some text" = "Some text"
--   encodeSafeTextString "0x is a prefix" = "0x3078206973206120707265666978"
--   
--   </pre>
--   
--   This function is used to serialize <tt>string</tt> values.
encodeSafeTextString :: Text -> Text

-- | Encode a bytestring in hexadecimal.
--   
--   This function is used to serialize <tt>bytesN</tt> and <tt>bytes</tt>
--   values.
encodeHexByteString :: ByteString -> Text

-- | Encode an integer in hexadecimal.
--   
--   This function is used to serialize huge <tt>intN</tt> and
--   <tt>uintN</tt> values. This allows other programs where native JSON
--   integers are limited by a relatively small number of bits to still
--   parse and accept large integers without loss of precision.
encodeHexInteger :: Integer -> Text


-- | This modules defines a runtime representation of strictly typed
--   Solidity values.
--   
--   This representation is composed of three parts:
--   
--   <ul>
--   <li>A <a>TypeContext</a> gives a mapping from type names to their
--   declarations for custom types (structs).</li>
--   <li>An <a>EthType</a> gives a type definition. Custom types here are
--   only referred by name, instead of being contained in their entirety,
--   so the exact representation of a value will depend on both a
--   <a>TypeContext</a> and an <a>EthValue</a>.</li>
--   <li>An <a>EthValue</a> is a type family that holds a Solidity object
--   of a given Solidity type.</li>
--   </ul>
--   
--   A mediator between the <a>EthType</a> and <a>EthValue</a> is
--   <a>EthRepr</a>, which is a stripped type-level version of
--   <a>EthType</a>. It contains only the information relevant to choosing
--   the appropriate Haskell type for representation within an
--   <a>EthValue</a>. And just like with <a>EthType</a>, custom types are
--   only referred by their names in <a>EthRepr</a> too, and similarly
--   require an addition of a type context (on a type level) to resolve
--   fully.
module Data.SignTyped.Structure

-- | A GADT defining a Solidity type. The type marker is an <a>EthRepr</a>
--   selecting the appropriate Haskell representation for the given
--   Solidity type.
data EthType rep

-- | Atomic types are defined fully in-place.
--   
--   They each have specific encodings and JSON mappings.
[EthTypeAtomic] :: AtomicEthType t -> EthType ('EthReprAtomic t)

-- | Array types are composed of a base type and an optional size.
--   
--   The encoding is <tt>keccak256</tt> of the concatenation of the
--   elements' encodings.
--   
--   In JSON, an array is represented as a JSON array.
[EthTypeArray] :: EthType rep -> Maybe Int -> EthType ('EthReprArray rep)

-- | Structs are kept as references, to be fully resolved later with a
--   <a>TypeContext</a>.
--   
--   The encoding is <tt>keccak256</tt> of a concatenation of the struct's
--   type hash (dependent on its definition in the type context) and the
--   encodings of its member values.
--   
--   In JSON, a struct is represented by a JSON object, with keys
--   corresponding to the struct members' names.
[EthTypeStruct] :: SName typename -> EthType ('EthReprStruct typename)

-- | A GADT that gives specific definitions for atomic types.
data AtomicEthType t

-- | Represented by Haskell <a>Bool</a>: Solidity <tt>bool</tt>.
--   
--   A <tt>bool</tt> is encoded as a <tt>uint256</tt>, with <a>False</a>
--   and <a>True</a> corresponding respectively to 0 and 1.
--   
--   In JSON, the literals <tt>false</tt> and <tt>true</tt> are used.
[AtomicEthTypeBool] :: AtomicEthType Bool

-- | Represented by Haskell <a>Integer</a>: Solidity <tt>intN</tt> and
--   <tt>uintN</tt>.
--   
--   When a number is encoded, it is sign-extended to 256 bits (32 bytes)
--   and written out in big-endian order.
--   
--   When serialized into JSON, the representation is dependent on the
--   value's magnitude: if it is small enough to fit in the
--   exact-integer-range of IEEE Double (which JSON numbers are usually
--   implemented as), then the number is written as-is. Otherwise, it is
--   converted to hexadecimal and written as a JSON string with preceding
--   <tt>0x</tt>.
--   
--   On input from JSON, either form for any magnitude is allowed. Since
--   Haskell's <tt>aeson</tt> always parses numbers precisely, it does not
--   suffer from Double's limitations.
[AtomicEthTypeInteger] :: AtomicIntegerSignedness -> AtomicIntegerBitSize -> AtomicEthType Integer

-- | Represented by Haskell <a>ByteString</a>: Solidity <tt>address</tt>,
--   <tt>bytesN</tt> and <tt>bytes</tt>.
--   
--   The single parameter further distinguishes between these variants,
--   controls the way values are encoded for signing and mapped to JSON for
--   sign requests, and can also impose restrictions on the value.
[AtomicEthTypeBytes] :: AtomicBytesSubtype -> AtomicEthType ByteString

-- | Represented by Haskell <a>Text</a>: Solidity <tt>string</tt>.
--   
--   The encoding is <tt>keccak256</tt> of the UTF-8 encoding of the
--   string.
--   
--   When serialized into JSON, the string is written out in literal text,
--   unless it starts with <tt>0x</tt> or <tt>0X</tt> or contains an
--   embedded zero, in which case it's encoded in UTF-8 and written in
--   hexadecimal, like <tt>bytes</tt>.
[AtomicEthTypeString] :: AtomicEthType Text

-- | Chooses between <tt>uintN</tt> and <tt>intN</tt> types.
data AtomicIntegerSignedness
AtomicIntegerUnsigned :: AtomicIntegerSignedness
AtomicIntegerSigned :: AtomicIntegerSignedness
type AtomicIntegerBitSize = Int

-- | A subcategory of a bytes-represented type.
data AtomicBytesSubtype

-- | Solidity <tt>address</tt>.
--   
--   The bytestring's length must be exactly 20.
--   
--   Upon encoding, the bytes are left-padded until the length of 32.
--   
--   In JSON, the addresses are represented as hexadecimal strings with the
--   mixed-case checksumming (ERC-55). The casing is strictly verified on
--   input.
AtomicBytesSubtypeAddress :: AtomicBytesSubtype

-- | Solidity <tt>bytesN</tt>, with the N given in the single parameter.
--   
--   The bytestring's length must be exactly N.
--   
--   Upon encoding, the bytes are right-padded until the length of 32.
--   
--   In JSON, the bytes are written out as a hexadecimal string. The input
--   is case-insensitive. On output, lowercase digits are produced.
AtomicBytesSubtypeShortBytes :: Int -> AtomicBytesSubtype

-- | Solidity <tt>bytes</tt>.
--   
--   There are no restrictions on the bytestring.
--   
--   The encoding is <tt>keccak256</tt> of the bytes.
--   
--   In JSON, the bytes are written out as a hexadecimal string. The input
--   is case-insensitive. On output, lowercase digits are produced.
AtomicBytesSubtypeLongBytes :: AtomicBytesSubtype

-- | Converts the marked type definition into a simple string.
--   
--   For the inverse conversion, see <a>parseUnmarkedEthType</a>.
ethTypeName :: EthType rep -> Text

-- | A kind for selecting a Haskell representation for a Solidity object.
data EthRepr
EthReprAtomic :: Type -> EthRepr
EthReprArray :: EthRepr -> EthRepr
EthReprStruct :: Symbol -> EthRepr

-- | Haskell representation of a Solidity object of the given type.
--   
--   The first parameter matches the representation with a
--   <a>TypeContext</a>, and the second with an <a>EthType</a>.
--   
--   To inspect an arbitrary <a>EthValue</a>, you will need its
--   corresponding <a>TypeContext</a> and <a>EthType</a>. As examples of
--   processing arbitrary objects using this type information, you can look
--   at the sources of <a>defaultEthValue</a>, <a>ethValueToEncoding</a>,
--   <a>ethValueParseJSON</a>, <a>hashEthValue</a> and other functions from
--   this package.
data family EthValue (ctx :: TMap Symbol [EthRepr]) (rep :: EthRepr)

-- | Generate a default value for a given type:
--   
--   <ul>
--   <li><tt>bool</tt> defaults to <a>False</a>.</li>
--   <li>Integer types default to 0.</li>
--   <li>Fixed-length strings (<tt>address</tt> and <tt>bytesN</tt>) are
--   filled with zero bytes.</li>
--   <li>Variable-length strings (<tt>bytes</tt> and <tt>string</tt>) are
--   defaulted to the empty string.</li>
--   <li>Fixed-length arrays are filled with the copies of the base type's
--   default value.</li>
--   <li>Variable-length arrays are defaulted empty.</li>
--   <li>Structs have each of their member defaulted.</li>
--   </ul>
defaultEthValue :: TypeContext ctx -> EthType rep -> EthValue ctx rep

-- | Checks equality of two Solidity objects of the same type.
--   
--   Since inspecting <a>EthValue</a>s requires type information to be
--   passed along with the value, we cannot do this in the standard
--   <a>(==)</a> operator.
eqEthValue :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> EthValue ctx rep -> Bool

-- | Compares the ordering of two Solidity objects of the same type.
--   
--   Since inspecting <a>EthValue</a>s requires type information to be
--   passed along with the value, we cannot do this in the standard
--   <a>compare</a> operator.
compareEthValue :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> EthValue ctx rep -> Ordering
type StructDef = HList MemberDef

-- | Structs are defines by their members, and each member is defined by
--   its name and type.
--   
--   The member type's representation marker is exposed as the marker of
--   the member itself. When collected into an <a>HList</a>, its combined
--   marker gives the representation of the entire structure, as a list of
--   representations of each of its members.
data MemberDef rep
[MemberDef] :: EthType rep -> Text -> MemberDef rep

-- | A type context is an <a>HMap</a> from struct names to their
--   definitions (member lists).
--   
--   In the context of Haskell's type system, a <a>TypeContext</a> is a
--   singleton — for each instance, the marker <tt>ctx</tt> will take on a
--   unique type of kind <tt><a>TMap</a> <a>SName</a>
--   <a>StructDef</a></tt>. Combined with <a>EthType</a>'s markers, this
--   makes this representation of Solidity objects in Haskell almost an
--   instance of dependent typing — where the values of the
--   <a>TypeContext</a> and <a>EthType</a> determine the exact type of an
--   <a>EthValue</a>.
--   
--   With the marker "hidden" under an existential, <tt>Some
--   TypeContext</tt> practically becomes a normal map. To that end, it
--   posesses an instance of <tt>Monoid (Some TypeContext)</tt>, which
--   allows one to construct a type context from individual definitions.
newtype TypeContext ctx
TypeContext :: HMap SName StructDef ctx -> TypeContext ctx
[typeContextMap] :: TypeContext ctx -> HMap SName StructDef ctx

-- | Produce an empty type context.
emptyTypeContext :: Some TypeContext

-- | Produce a type context with a single definition.
singletonTypeContext :: SName typename -> StructDef reps -> Some TypeContext

-- | Perform a safe lookup in a type context. If the given key is absent,
--   <a>Nothing</a> is returned.
lookupStructDef :: TypeContext ctx -> SName typename -> Maybe (StructDef (Lookup typename ctx))

-- | Perform a strict lookup in a type context. If the given key is absent,
--   an <a>error</a> is raised.
--   
--   The continuation-passing style of this function allows one to put an
--   arbitrary expression dependent on the check, so that even if the
--   struct definition itself ends up being unused due to lazyness, the
--   key-presence check will be performed anyway.
withStructDef :: TypeContext ctx -> SName typename -> (StructDef (Lookup typename ctx) -> r) -> r

-- | Prints a Solidity object into a <a>ShowS</a>-string. This is intended
--   solely for debugging purposes, so the output is not guaranteed to
--   conform to any format or even be unambiguous.
--   
--   If you want to properly serialize a Solidity object, you should use
--   <a>ethValueToJSON</a> or <a>ethValueToEncoding</a> instead.
showsEthValue :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> ShowS

-- | Prints a struct definition into a <a>ShowS</a>-string. This is
--   intended solely for debugging purposes, so the output is not
--   guaranteed to conform to any format or even be unambiguous.
--   
--   If you want to properly serialize a struct definition, you should
--   instead use <a>toUnmarkedStructDef</a>, followed by any of the Aeson's
--   serialization routines.
showsEthStructDef :: SName typename -> StructDef reps -> ShowS

-- | Prints a type context into a <a>ShowS</a>-string. This is intended
--   solely for debugging purposes, so the output is not guaranteed to
--   conform to any format or even be unambiguous.
--   
--   If you want to properly serialize a type context, you should instead
--   use <a>toUnmarkedTypeContext</a>, followed by any of the Aeson's
--   serialization routines.
showsTypeContext :: TypeContext ctx -> ShowS

-- | A Solidity object wrapped together with its type.
--   
--   This wrapper is intended to be used in test suites, where assertions
--   expect the objects to have standard <a>Show</a> and <a>Eq</a>
--   instances, for example as arguments to <a>shouldBe</a>.
data SomeEthValue
SomeEthValue :: TypeContext ctx -> EthType repr -> EthValue ctx repr -> SomeEthValue

-- | Performs validation checks on the given object and returns the list of
--   errors.
--   
--   This function checks for additional conditions imposed by the Solidity
--   type definition that are not part of the representation's Haskell type
--   itself, such as the integer values being in range of their types, or
--   fixed-size arrays having a proper number of elements.
--   
--   The default handles from <a>SignableValue</a>, as well as
--   <a>ethValueParseJSON</a> perform their own validation to produce only
--   correct Solidity objects, so this specific function is better suited
--   as a debug tool rather than a routine checker in the main code.
validateEthValue :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> [String]

-- | Internal recursive function for <a>validateEthValue</a>.
--   
--   The first argument is a <a>ShowS</a>-encoded prefix of the value's
--   location (e.g. <tt>showString ".elems[3].first"</tt>).
--   
--   The partial list is returned as a difference-list.
--   
--   The default entrypoint is defined like this:
--   
--   <pre>
--   validateEthValue tc ethType ethValue =
--       validateEthValueWorker (showString "$") tc ethType ethValue []
--   
--   </pre>
validateEthValueWorker :: ShowS -> TypeContext ctx -> EthType rep -> EthValue ctx rep -> [String] -> [String]

-- | Check that the given integer fits within the given type.
isValidInteger :: AtomicIntegerSignedness -> AtomicIntegerBitSize -> Integer -> Bool
instance GHC.Classes.Eq Data.SignTyped.Structure.AtomicIntegerSignedness
instance GHC.Show.Show Data.SignTyped.Structure.AtomicIntegerSignedness
instance GHC.Classes.Eq Data.SignTyped.Structure.AtomicBytesSubtype
instance GHC.Show.Show Data.SignTyped.Structure.AtomicBytesSubtype
instance Data.Type.Equality.TestEquality Data.SignTyped.Structure.TypeContext
instance GHC.Show.Show (Data.SignTyped.Structure.EthType rep)
instance GHC.Show.Show (Data.SignTyped.Structure.AtomicEthType t)
instance GHC.Show.Show (Data.SignTyped.Structure.MemberDef rep)
instance GHC.Show.Show Data.SignTyped.Structure.SomeEthValue
instance GHC.Classes.Eq Data.SignTyped.Structure.SomeEthValue
instance GHC.Show.Show (Data.SignTyped.Structure.TypeContext ctx)
instance GHC.Base.Semigroup (Data.SignTyped.Type.Some.Some Data.SignTyped.Structure.TypeContext)
instance GHC.Base.Monoid (Data.SignTyped.Type.Some.Some Data.SignTyped.Structure.TypeContext)
instance Data.Type.Equality.TestEquality Data.SignTyped.Structure.MemberDef
instance Data.Type.Equality.TestEquality Data.SignTyped.Structure.EthType
instance Data.Type.Equality.TestEquality Data.SignTyped.Structure.AtomicEthType


-- | This modules defines the JSON format of Solidity types and objects.
--   
--   For types, we define an intermediate representation, composed of
--   conventional <tt>data</tt>s with standard Aeson instances, and
--   functions for conversion between this intermediate representation and
--   <a>Data.SignTypes.Structure</a>'s objects.
--   
--   For values, we convert between <a>EthValue</a>'s and JSON directly.
module Data.SignTyped.Json

-- | A representation of a type context without the type-level markings,
--   used as an intermediate between the marked <a>TypeContext</a> and
--   completely untyped <a>Value</a>.
type UnmarkedTypeContext = Map Text UnmarkedStructDef
type UnmarkedStructDef = [UnmarkedMemberDef]
data UnmarkedMemberDef
UnmarkedMemberDef :: UnmarkedEthType -> Text -> UnmarkedMemberDef
[_type] :: UnmarkedMemberDef -> UnmarkedEthType
[_name] :: UnmarkedMemberDef -> Text
type UnmarkedEthType = Text
toUnmarkedTypeContext :: TypeContext ctx -> UnmarkedTypeContext
toUnmarkedStructDef :: StructDef reps -> UnmarkedStructDef
toUnmarkedMemberDef :: MemberDef rep -> UnmarkedMemberDef
toUnmarkedEthType :: EthType rep -> UnmarkedEthType

-- | Convert an unmarked type context into a proper one.
--   
--   This function also verifies that all types that are used in the
--   context are either defined in the same context, or are built-in
--   Solidity types.
parseUnmarkedTypeContext :: UnmarkedTypeContext -> Parser (Some TypeContext)

-- | Parse an unmarked struct definition.
--   
--   This function also verifies that the there are no members with the
--   same name.
--   
--   In addition to the proper struct definition, this function also
--   returns the set of custom types that are used in this struct.
parseUnmarkedStructDef :: UnmarkedStructDef -> Parser (Set Text, Some StructDef)

-- | Parse an unmarked struct member definition.
--   
--   In addition to the proper member definition, this function also
--   returns the set of custom types that are used in the member.
parseUnmarkedMemberDef :: UnmarkedMemberDef -> Parser (Set Text, Some MemberDef)

-- | Parse an unmarked type definition.
--   
--   In addition to the proper type definition, this function also returns
--   the set of custom types that are used here.
parseUnmarkedEthType :: Text -> Parser (Set Text, Some EthType)

-- | Implementation of <a>toJSON</a> for a typed Solidity object.
ethValueToJSON :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> Value

-- | Implementation of <a>toEncoding</a> for a typed Solidity object.
ethValueToEncoding :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> Encoding

-- | Implementation of <a>parseJSON</a> for a typed Solidity object.
--   
--   <tt>null</tt> is accepted, and corresponds to <a>defaultEthValue</a>.
ethValueParseJSON :: TypeContext ctx -> EthType rep -> Value -> Parser (EthValue ctx rep)

-- | IEEE double-presicion numbers can represent integers within the range
--   [-2^52 .. 2^52] exactly.
--   
--   This function tests whether the given integer belongs to this range.
isJsonRepresentableInteger :: Integer -> Bool
instance GHC.Real.Integral Data.SignTyped.Json.AnyEthInteger
instance GHC.Real.Real Data.SignTyped.Json.AnyEthInteger
instance GHC.Num.Num Data.SignTyped.Json.AnyEthInteger
instance GHC.Enum.Enum Data.SignTyped.Json.AnyEthInteger
instance GHC.Classes.Ord Data.SignTyped.Json.AnyEthInteger
instance GHC.Classes.Eq Data.SignTyped.Json.AnyEthInteger
instance GHC.Enum.Bounded Data.SignTyped.Json.AnyEthInteger
instance Data.Aeson.Types.ToJSON.ToJSON Data.SignTyped.Json.UnmarkedMemberDef
instance Data.Aeson.Types.FromJSON.FromJSON Data.SignTyped.Json.UnmarkedMemberDef
instance GHC.Classes.Ord Data.SignTyped.Json.UnmarkedMemberDef
instance GHC.Classes.Eq Data.SignTyped.Json.UnmarkedMemberDef
instance GHC.Show.Show Data.SignTyped.Json.UnmarkedMemberDef

module Data.SignTyped.Hashing

-- | Produce the hash of the data to be signed.
--   
--   This corresponds to the <tt>encodeData</tt> operation of the
--   specification.
hashEthValue :: TypeContext ctx -> EthType rep -> EthValue ctx rep -> ByteString

-- | Produce the hash of the struct value to be signed.
--   
--   This corresponds to the <tt>hashStruct</tt> operation of the
--   specification.
hashEthStruct :: TypeContext ctx -> SName typename -> HList (EthValue ctx) (Lookup typename ctx) -> ByteString

-- | Collects all structs transitively used in defining the current one,
--   including itself, and returns a map from struct names to their
--   signatures.
--   
--   For example, given this set of definitions in the type context:
--   
--   <pre>
--   struct Person {
--       string name;
--       address wallet;
--   }
--   
--   struct Mail {
--       Person from;
--       Person to;
--       string contents;
--   }
--   
--   </pre>
--   
--   This function will return these results:
--   
--   <pre>
--   structLocalContext tc (SName @"Person") =
--       fromList
--           [("Person", "Person(string name,address wallet)")]
--   
--   structLocalContext tc (SName @"Mail") =
--       fromList
--           [("Mail",   "Mail(Person from,Person to,string contents)"),
--            ("Person", "Person(string name,address wallet)")]
--   
--   </pre>
--   
--   This function is used as part of <a>structTypeFullSignature</a>.
structLocalContext :: TypeContext ctx -> SName typename -> Map Text ByteString

-- | Returns the argument of the type hash of the selected struct.
--   
--   This corresponds to the <tt>encodeType</tt> operation in the
--   specification.
structTypeFullSignature :: TypeContext ctx -> SName typename -> ByteString


-- | We use <a>Crypto.Secp256k1.Recovery</a> as a back-end for the
--   cryptographic operations.
module Data.SignTyped.Crypto
type MessageHash = Msg
type Signature = ByteString
type Address = ByteString

-- | Derive an Ethereum-compatible address from a public key.
pubKeyToAddress :: Ctx -> PubKey -> Address

-- | Sign a given message with a given secret key. The signature produced
--   is the 65-byte (v,r,s) recoverable signature.
--   
--   If a chainId is provided, it will be encoded to the v byte of the
--   signature according to EIP-155, as an offset of (chainId * 2 + 36).
--   Otherwise, the default offset of 27 is used.
messageHashSign :: Ctx -> SecKey -> Maybe Int -> MessageHash -> Signature

-- | Recover an address from a given message and a given (v,r,s) signature.
--   
--   For the v component, the default offset of 27 is always allowed. If a
--   chainId is provided, its offset of (chainId * 2 + 36) will also be
--   tried.
--   
--   In the special case of <tt>chainId = 124 + 128 k</tt>, the value of
--   <tt>v = 28</tt> becomes ambiguous — it could mean both the odd parity
--   with the default offset 27, and the even parity with the
--   chainId-specific offset of 28. In this case, this function interprets
--   it as the latter (the chainId-specific offset takes priority).
messageHashRecover :: Ctx -> Maybe Int -> MessageHash -> Signature -> Maybe Address

-- | Verify that a given (v,r,s) signature on a given message corresponds
--   to a given address.
--   
--   This function simply recovers the address with
--   <a>messageHashRecover</a> and compares it to the one given.
messageHashVerify :: Ctx -> Maybe Int -> MessageHash -> Signature -> Address -> Bool

module Data.SignTyped.Class

-- | Perform EIP-712 <tt>encodeData</tt> on the given value with its type's
--   default handle.
hashSignable :: forall a baseType. SignableValueDefault baseType a => a -> Either String ByteString

-- | Perform EIP-712 <tt>encodeData</tt> on the given value using the given
--   handle.
hashSignableWith :: forall a. SignableValueHandle a -> a -> Either String ByteString

-- | <tt>SignableValue baseType a</tt> allows a Haskell value of type
--   <tt>a</tt> to be represented as a Solidity value with the typename
--   <tt>baseType</tt>.
--   
--   The relation between Solidity and Haskell types is many-to-many. For
--   example, Solidity's <tt>uint64</tt> can be produced from any of
--   <a>Word</a>, <a>Int</a>, <a>Natural</a> or <a>Integer</a>. On the
--   other hand, Haskell's <a>Integer</a> can be mapped to any of
--   Solidity's numeric types.
--   
--   The actual implementation is delegated to a <a>SignableValueHandle</a>
--   object, which allows us some additional flexibility:
--   
--   <ul>
--   <li>The <a>SignableValue</a> itself is treated as a <i>default</i>
--   implementation rather than the <i>canonical</i> one.</li>
--   <li>To define an instance of <a>SignableValue</a>, one only needs to
--   perform a single assignment, most often from a handle-template
--   function, instead of repeating the same parameters across multiple
--   class method definitions.</li>
--   </ul>
class SignableValue (baseType :: Symbol) a
signableValueHandle :: SignableValue baseType a => SignableValueHandle a
signableValueListHandle :: SignableValue baseType a => SignableValueHandle [a]

-- | This typeclass sets one of the Solidity typenames as the default
--   correspondence for the given Haskell type.
class (SignableValue baseType a) => SignableValueDefault baseType a | a -> baseType

-- | A version of <a>signableValueHandle</a> that uses the stronger
--   <a>SignableValueDefault</a> constraint.
signableValueDefaultHandle :: forall a baseType. SignableValueDefault baseType a => SignableValueHandle a

-- | This newtype is intended to be used as a wrapper for DerivingVia to
--   derive <a>SignableValue</a>, for example:
--   
--   <pre>
--   data MyPerson = MyPerson
--       { pname :: String
--       , pwallet :: BS.ByteString
--       }
--       deriving (Show, Eq, Generic)
--       deriving (SignableValue "Person") via (
--           GenericSignable
--               '[  'SigningFieldModifier "pname"
--                       ('Just "name")
--                       ('Just (AsBaseType "string" String))
--               ,   'SigningFieldModifier "pwallet"
--                       ('Just "wallet")
--                       ('Just (AsBaseType "address" BS.ByteString))
--               ]
--               MyPerson
--       )
--       deriving anytype (SignableValueDefault "Person")
--   
--   </pre>
--   
--   <tt>mods</tt> is a <tt>DataKinds</tt> parameter that is used to
--   fine-tune the generated instance, similar to aeson's <a>Options</a>,
--   but on a type level instead of the value level.
newtype GenericSignable (mods :: [SigningModifier]) a
GenericSignable :: AssertValidation (ValidateModifiers mods (Rep a)) a -> GenericSignable (mods :: [SigningModifier]) a
[unwrapGenericSignable] :: GenericSignable (mods :: [SigningModifier]) a -> AssertValidation (ValidateModifiers mods (Rep a)) a

-- | A datatype for <a>GenericSignable</a> modifiers. It's intended to be
--   used at type level with DataKinds.
--   
--   Each modifier in the list can be thought of as an assignment of the
--   provided value to a configuration parameter.
--   
--   <tt>SigningFieldModifier "haskellFieldName" mbEthName mbSignType</tt>
--   configures the field, which is referred to in Haskell by the selector
--   <tt>haskellFieldName</tt>. <tt>mbEthName</tt> and <tt>mbSignType</tt>
--   are optional new configuration values: <tt>'Just smth</tt> sets the
--   configuration to the specified value, while <tt>'Nothing</tt> leaves
--   it unchanged.
--   
--   The second parameter, <tt>mbEthName</tt>, sets the name of the field
--   in Solidity. By default, the Haskell selector's name is used.
--   
--   The third paremeter, <tt>mbSignType</tt>, is a
--   <tt>DerivingVia</tt>-style wrapper that configures a "signing type".
--   This type must have a valid <a>SignableValueDefault</a> instance, and,
--   obviously, be <a>Coercible</a> with the actual field's type.
data SigningModifier
SigningFieldModifier :: Symbol -> Maybe Symbol -> Maybe Type -> SigningModifier

-- | A generic implementation of the signable handle. You can use this
--   function instead of <a>GenericSignable</a> to define your own handle
--   or instance, for example:
--   
--   <pre>
--   data MyPerson = MyPerson
--       { pname :: String
--       , pwallet :: BS.ByteString
--       }
--       deriving (Show, Eq, Generic)
--   
--   myPersonSignableValueHandle :: SignableValueHandle MyPerson
--   myPersonSignableValueHandle =
--       genericSignableValueHandle
--           @"Person"
--           @'[ 'SigningFieldModifier "pname"
--                   ('Just "name")
--                   ('Just (AsBaseType "string" String))
--           ,   'SigningFieldModifier "pwallet"
--                   ('Just "wallet")
--                   ('Just (AsBaseType "address" BS.ByteString))
--           ]
--   
--   instance SignableValue "Person" MyPerson where
--       signableValueHandle = myPersonSignableValueHandle
--   
--   instance SignableValueDefault "Person" MyPerson where {}
--   
--   </pre>
genericSignableValueHandle :: forall baseType mods s. (Generic s, AssertValidation (ValidateModifiers mods (Rep s)) (() :: Constraint), GSignableRep mods s (Rep s), KnownSymbol baseType) => SignableValueHandle s

-- | This is a newtype wrapper that's indended to be used with
--   <a>SigningFieldModifier</a>.
--   
--   It sets the Solidity typename to be used for this Haskell type. This
--   allows you to use a <a>SignableValue</a> instance that is different
--   from default, or on types that don't even define a default, such as
--   <a>Integer</a> and <a>ByteString</a>.
newtype AsBaseType (baseType :: Symbol) a
AsBaseType :: a -> AsBaseType (baseType :: Symbol) a

-- | This is a newtype wrapper that's indended to be used with
--   <a>SigningFieldModifier</a>.
--   
--   Being a wrapper for an array, it allows you to set a fixed size to the
--   array, as opposed to having the default option to map the Haskell list
--   to a variable-length array.
--   
--   For example, representing a Solidity structure <tt>Rectangle
--   {int256[2] minpos; int256[2] maxpos}</tt> could be done like this:
--   
--   <pre>
--   data Rectangle = Rectangle
--       { minpos :: [Integer]
--       , maxpos :: [Integer]
--       }
--       deriving (Generic)
--       deriving (SignableValue "Rectangle") via (
--           GenericSignable
--               '[  'SigningFieldModifier "minpos"
--                       'Nothing
--                       ('Just (AsSized 2 (AsBaseType "int256" Integer)))
--               ,   'SigningFieldModifier "maxpos"
--                       'Nothing
--                       ('Just (AsSized 2 (AsBaseType "int256" Integer)))
--               ]
--               Rectangle
--       )
--   
--   </pre>
newtype AsSized (arrSize :: Nat) a
AsSized :: [a] -> AsSized (arrSize :: Nat) a

-- | This handle encodes Haskell <a>Bool</a> into Solidity's <tt>bool</tt>:
--   
--   <ul>
--   <li><a>False</a> is encoded as <tt><a>replicate</a> 32 0</tt>.</li>
--   <li><a>True</a> is encoded as <tt><a>replicate</a> 31 0 &lt;&gt;
--   'x01'</tt>.</li>
--   </ul>
boolValueHandle :: SignableValueHandle Bool

-- | This handle encodes Haskell <a>Integer</a> into a Solidity's integer
--   type: sign-extended to 256 bits (32 bytes) and serialized in the
--   big-endian order.
--   
--   The two parameters define signedness and bit size of the integer.
numberValueHandle :: AtomicIntegerSignedness -> AtomicIntegerBitSize -> SignableValueHandle Integer

-- | This handle encodes Haskell <a>ByteString</a> into Solidity's
--   <tt>address</tt>, <tt>bytesN</tt> or <tt>bytes</tt>.
--   
--   The single parameter chooses a subtype:
--   
--   <ul>
--   <li><a>AtomicBytesSubtypeAddress</a> allows bytestrings of length 20,
--   and encodes it as an <tt>address</tt>: left-padded with zero bytes
--   until the length of 32.</li>
--   <li><tt><a>AtomicBytesSubtypeShortBytes</a> N</tt> allows bytestrings
--   with length of exactly <tt>N</tt>, and encodes it as a
--   <tt>bytesN</tt>: right-padded with zero bytes until the length of 32.
--   The handle will only make a valid encoding for <tt>1 &lt;= N &lt;=
--   32</tt>.</li>
--   <li><a>AtomicBytesSubtypeLongBytes</a> allows bytestrings of any
--   length and any contents, and encodes it as <tt>bytes</tt>: by taking
--   the <tt>keccak256</tt> of the bytes.</li>
--   </ul>
bytesValueHandle :: AtomicBytesSubtype -> SignableValueHandle ByteString

-- | This handle encodes Haskell <a>Text</a> into Solidity's
--   <tt>string</tt>: by taking the <tt>keccak256</tt> of the UTF-8
--   encoding of the string.
stringValueHandle :: SignableValueHandle Text

-- | This handle encodes the array type.
--   
--   The first parameter is the handle for the underlying type, it will be
--   used to encode each element of the array. The second parameter is the
--   size of the array: a <a>Just</a>-number for a fixed-size array (e.g.
--   <tt>address[32]</tt>) or <a>Nothing</a> for a variable-length array
--   (e.g. <tt>string[]</tt>).
--   
--   The encoding in both cases is the <a>keccak256</a> of the
--   concatenation of the content's encodings.
--   
--   If the array is fixed-sized, then the actual value's length will be
--   validated upon encoding.
arrayValueHandle :: SignableValueHandle a -> Maybe Int -> SignableValueHandle [a]

-- | This handle encodes a struct type.
--   
--   The encoding of a struct is <tt>keccak256</tt> of the concatenation of
--   the struct's typehash and each of its value's encoding in their
--   definition order.
--   
--   An example usage of this function:
--   
--   <pre>
--   data MyPerson = MyPerson
--       { pname :: String
--       , pwallet :: BS.ByteString
--       }
--       deriving (Show, Eq, Generic)
--   
--   myPersonSignableValueHandle :: SignableValueHandle MyPerson
--   myPersonSignableValueHandle =
--       structValueHandle
--           (SName @"Person")
--           [   SignableStructMemberHandle "name" pname (signableValueHandle @"string")
--           ,   SignableStructMemberHandle "wallet" pwallet (signableValueHandle @"address")
--           ]
--   
--   </pre>
structValueHandle :: forall s structName. SName structName -> [SignableStructMemberHandle s] -> SignableValueHandle s

-- | A handle for a specific field of a struct, to be used in
--   <a>structValueHandle</a>.
data SignableStructMemberHandle s
SignableStructMemberHandle :: Text -> (s -> a) -> SignableValueHandle a -> SignableStructMemberHandle s

-- | The handle that defines how a given Haskell value shall be encoded
--   into a Solidity-compatible representation.
--   
--   Normally, you should use one of the pre-defined handle factories, and
--   possibly <a>contramap</a> or <a>contramapSignableEither</a> them onto
--   your type.
--   
--   <a>EthType</a> is a declaration of the Solidity type. Atomic types are
--   declared completely, while struct types are declared only by a
--   reference into a "type context". This allows multiple struct types to
--   recursively refer to each other, a feature that's explicitly supported
--   by EIP-712.
--   
--   The encoding is done in two phases:
--   
--   <ul>
--   <li>Firstly, we collect all struct definitions that are used in the
--   root value to create the <a>TypeContext</a>.</li>
--   <li>Then, we actually traverse the given object, while resolving the
--   struct-referencing <a>EthType</a>s with the constructed
--   <a>TypeContext</a>.</li>
--   </ul>
--   
--   When building the type context, recursive struct definitions can lead
--   to a value recursion in Haskell. For this reason, the primary source
--   for a single handle is a value of <a>TypeContextBuilder</a>, which is
--   a single struct definition followed by a list of its dependencies.
--   When traversing the <a>TypeContextBuilder</a>s, we can detect this
--   kind of recursion by an explicit check and thus avoid getting stuck in
--   an infinite loop when constructing the singular <a>TypeContext</a>
--   object.
--   
--   The Solidity value representation uses quite a bit of type magic to
--   ensure consistency, but it's still not enough to prove that a struct
--   within a <a>TypeContext</a> will exactly match the
--   <a>TypeContextBuilder</a> that it came from. For this reason,
--   <a>signableValueEmbed</a> takes a separate <a>EthType</a>, which may
--   be different from the one given in <a>signableValueEthType</a>, and is
--   allowed to report a mismatch between the Haskell type and the Solidity
--   representation though the <a>MonadFail</a> instance of the
--   <a>Embed</a> monad.
data SignableValueHandle a
SignableValueHandle :: Some EthType -> Maybe TypeContextBuilder -> Some TypeContext -> (forall ctx rep. EthType rep -> a -> Embed ctx (EthValue ctx rep)) -> SignableValueHandle a

-- | The Solidity type that the values of this Haskell type <i>should</i>
--   be mapped to.
[signableValueEthType] :: SignableValueHandle a -> Some EthType

-- | A "builder" for the type context. If this handle corresponds to a
--   struct, this will be <a>Just</a> the definition of this struct and a
--   list of its members' dependencies. Otherwise, this will be
--   <a>Nothing</a>.
[signableValueTypeContextBuilder] :: SignableValueHandle a -> Maybe TypeContextBuilder

-- | The cached result of calling <a>executeTypeContextBuilder</a> on this
--   handle's builder.
[signableValueTypeContext] :: SignableValueHandle a -> Some TypeContext

-- | The encoder function. It's given a <a>TypeContext</a> as part of the
--   <a>Embed</a> monad, an <a>EthType</a> and a Haskell value, and should
--   either encode the given value according to the given <a>EthType</a>,
--   or report a failure through the monad.
[signableValueEmbed] :: SignableValueHandle a -> forall ctx rep. EthType rep -> a -> Embed ctx (EthValue ctx rep)
contramap :: Contravariant f => (a' -> a) -> f a -> f a'

-- | A generalization of <tt><a>contramap</a> @SignableValueHandle</tt>
--   that allows you to perform run-time checks and fail gracefully by
--   returning a <a>Left</a>. An error produced in this way will be
--   annotated with a JSONPath-like location in the object where it
--   happened.
--   
--   If the conversion is total, you can use <a>contramap</a> instead.
contramapSignableEither :: (a -> Either String b) -> SignableValueHandle b -> SignableValueHandle a

-- | A builder of a <a>TypeContext</a>. This structure is specifically
--   designed to allow value recursion, so that a definition like this
--   would be legal:
--   
--   <pre>
--   data FoobarTree = FoobarTree
--       { stData :: Foobar
--       , stChildren :: [FoobarTree]
--       }
--   
--   foobarTreeTCB :: TypeContextBuilder
--   foobarTreeTCB =
--       TypeContextBuilder
--           (Some $ SName @"FoobarTree")
--           (Some $
--               MemberDef
--                   (EthTypeStruct (SName @"Foobar"))
--                   "data"
--             :/
--               MemberDef
--                   (EthTypeArray (EthTypeStruct (SName @"FoobarTree")) Nothing)
--                   "children"
--             :/
--               HEnd
--           )
--           [ foobarTCB
--           , foobarTreeTCB -- value recursion
--           ]
--   
--   </pre>
data TypeContextBuilder
TypeContextBuilder :: Some SName -> Some StructDef -> [TypeContextBuilder] -> TypeContextBuilder

-- | Fold a <a>TypeContextBuilder</a> into a <a>TypeContext</a>.
executeTypeContextBuilder :: TypeContextBuilder -> Some TypeContext

-- | A monad that is used for the main phase of the value encoding. Its
--   structure can be represented by this stack:
--   
--   <pre>
--     Embed ctx
--   
--   is-semantically-equivalent-to
--   
--     ReaderT (TypeContext ctx) -- The type context that all of the struct-referring <a>EthType</a>s point to
--   .
--     ReaderT String -- The current position in the value, for error messages
--   .
--     ExceptT String -- Type mismatch errors
--   
--   </pre>
newtype Embed ctx a
Embed :: (forall r. TypeContext ctx -> ShowS -> (String -> r) -> (a -> r) -> r) -> Embed ctx a
[withEmbed] :: Embed ctx a -> forall r. TypeContext ctx -> ShowS -> (String -> r) -> (a -> r) -> r

-- | The driver of the <a>Embed</a> actions.
runEmbed :: TypeContext ctx -> Embed ctx a -> Either String a

-- | <tt>local</tt>-like function that appends the given string to the
--   current location.
withEmbedLocation :: String -> Embed ctx a -> Embed ctx a

-- | <a>withEmbedLocation</a> specialization that appends an array index.
withEmbedLocationArrayElement :: Int -> Embed ctx a -> Embed ctx a

-- | <a>withEmbedLocation</a> specialization that appends a member access.
withEmbedLocationStructMember :: Text -> Embed ctx a -> Embed ctx a

-- | Retrieve the current type context.
askTypeContext :: Embed ctx (TypeContext ctx)

-- | Lookup a struct definition by its name in the current type context.
getStructDef :: SName typename -> Embed ctx (StructDef (Lookup typename ctx))

-- | Helper typeclass for the generic implementation of
--   <a>SignableValue</a>.
--   
--   The role of <a>GSignableRep</a> is to collect information about the
--   fields of the structure. This list of fields is then used as a
--   parameter to <a>structValueHandle</a> to make the complete handle.
--   
--   Type parameter <tt>s</tt> stands for the original Haskell type, which
--   the handle is being built for; and <tt>g</tt> is a
--   <tt>GHC.Generics</tt>-representation of a part within the original
--   value.
class GSignableRep (mods :: [SigningModifier]) s g
gSignableRepMemberHandles :: GSignableRep mods s g => (s -> g ()) -> [SignableStructMemberHandle s]

-- | <tt>ModifiedFieldName hsel mods</tt> is the Solidity field name that
--   <tt>mods</tt> assign to selector <tt>hsel</tt>.
type family ModifiedFieldName hsel mods

-- | <tt>ModifiedFieldType hsel mods</tt> is the wrapper type that
--   <tt>mods</tt> assign to selector <tt>hsel</tt>.
type family ModifiedFieldType hsel mods

-- | <tt>ValidateModifiers mods rep</tt> checks that the modifier list
--   <tt>mods</tt>:
--   
--   <ul>
--   <li>is internally consistent: it does not assign different names or
--   different types to the same field, and</li>
--   <li>is applicable to the generic representation <tt>rep</tt>: it does
--   not assign to fields that are not actually present in the
--   structure.</li>
--   </ul>
--   
--   If the checks pass, it reduces to <tt>'Nothing</tt>, otherwise it's
--   <tt>'Just</tt> with the description of the failure as a type-level
--   <a>ErrorMessage</a>.
type family ValidateModifiers mods rep

-- | <tt>AssertValidation mbx r</tt> reduces to <tt>r</tt> if <tt>mbx ~
--   'Nothing</tt>, otherwise it's <tt>TypeError</tt>.
--   
--   It's intended to be used with <a>ValidateModifiers</a> type family, in
--   the form <tt>AssertValidation (ValidateModifiers mods rep) r</tt>.
--   
--   The reason it's split into a separate type family is to allow a form
--   of validation that <i>does not</i> throw a type error on failure:
--   <tt>ValidateModifiers mods rep ~ 'Nothing</tt>. This is sometimes used
--   in conjunction with the "throwing" version to avoid duplicate error
--   messages.
type family AssertValidation mbx r
instance Data.SignTyped.Class.SignableValue "bytes1" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes2" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes3" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes4" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes5" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes6" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes7" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes8" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes9" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes10" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes11" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes12" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes13" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes14" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes15" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes16" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes17" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes18" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes19" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes20" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes21" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes22" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes23" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes24" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes25" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes26" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes27" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes28" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes29" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes30" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes31" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes32" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "bytes" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "string" Data.ByteString.Internal.Type.ByteString
instance Data.SignTyped.Class.SignableValue "string" Data.Text.Internal.Text
instance Data.SignTyped.Class.SignableValue "string" GHC.Types.Char
instance Data.SignTyped.Class.SignableValueDefault baseType a => Data.SignTyped.Class.SignableValueDefault baseType [a]
instance Data.SignTyped.Class.SignableValueDefault "bool" GHC.Types.Bool
instance Data.SignTyped.Class.SignableValueDefault "int8" GHC.Int.Int8
instance Data.SignTyped.Class.SignableValueDefault "int16" GHC.Int.Int16
instance Data.SignTyped.Class.SignableValueDefault "int32" GHC.Int.Int32
instance Data.SignTyped.Class.SignableValueDefault "int64" GHC.Int.Int64
instance Data.SignTyped.Class.SignableValueDefault "uint8" GHC.Word.Word8
instance Data.SignTyped.Class.SignableValueDefault "uint16" GHC.Word.Word16
instance Data.SignTyped.Class.SignableValueDefault "uint32" GHC.Word.Word32
instance Data.SignTyped.Class.SignableValueDefault "uint64" GHC.Word.Word64
instance Data.SignTyped.Class.SignableValueDefault "string" Data.Text.Internal.Text
instance Data.SignTyped.Class.SignableValueDefault "string" GHC.Types.Char
instance Data.SignTyped.Class.SignableValue "int8" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int16" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int24" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int32" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int40" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int48" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int56" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int64" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int72" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int80" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int88" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int96" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int104" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int112" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int120" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int128" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int136" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int144" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int152" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int160" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int168" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int176" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int184" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int192" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int200" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int208" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int216" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int224" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int232" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int240" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int248" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "int256" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint8" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint16" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint24" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint32" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint40" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint48" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint56" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint64" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint72" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint80" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint88" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint96" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint104" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint112" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint120" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint128" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint136" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint144" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint152" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint160" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint168" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint176" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint184" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint192" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint200" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint208" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint216" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint224" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint232" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint240" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint248" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint256" GHC.Num.Integer.Integer
instance Data.SignTyped.Class.SignableValue "uint8" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint16" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint24" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint32" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint40" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint48" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint56" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint64" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint72" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint80" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint88" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint96" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint104" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint112" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint120" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint128" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint136" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint144" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint152" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint160" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint168" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint176" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint184" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint192" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint200" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint208" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint216" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint224" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint232" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint240" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint248" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "uint256" GHC.Num.Natural.Natural
instance Data.SignTyped.Class.SignableValue "int8" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int16" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int24" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int32" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int40" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int48" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int56" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "int64" GHC.Types.Int
instance Data.SignTyped.Class.SignableValue "uint8" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint16" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint24" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint32" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint40" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint48" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint56" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "uint64" GHC.Types.Word
instance Data.SignTyped.Class.SignableValue "int8" GHC.Int.Int8
instance Data.SignTyped.Class.SignableValue "int16" GHC.Int.Int16
instance Data.SignTyped.Class.SignableValue "int32" GHC.Int.Int32
instance Data.SignTyped.Class.SignableValue "int64" GHC.Int.Int64
instance Data.SignTyped.Class.SignableValue "uint8" GHC.Word.Word8
instance Data.SignTyped.Class.SignableValue "uint16" GHC.Word.Word16
instance Data.SignTyped.Class.SignableValue "uint32" GHC.Word.Word32
instance Data.SignTyped.Class.SignableValue "uint64" GHC.Word.Word64
instance Data.SignTyped.Class.SignableValue "address" Data.ByteString.Internal.Type.ByteString
instance GHC.Base.Functor (Data.SignTyped.Class.Embed ctx)
instance Data.SignTyped.Class.SignableValue baseType a => Data.SignTyped.Class.SignableValue baseType (Data.SignTyped.Class.AsBaseType otherBaseType a)
instance (GHC.Generics.Generic s, Data.SignTyped.Class.ValidateModifiers mods (GHC.Generics.Rep s) GHC.Types.~ 'GHC.Maybe.Nothing, Data.SignTyped.Class.GSignableRep mods s (GHC.Generics.Rep s), GHC.TypeLits.KnownSymbol baseType) => Data.SignTyped.Class.SignableValue baseType (Data.SignTyped.Class.GenericSignable mods s)
instance (Data.SignTyped.Class.SelectedFieldName (Data.SignTyped.Class.ModifiedFieldName hsel mods) hsel ethFieldName, Data.SignTyped.Class.SelectedFieldSignType (Data.SignTyped.Class.ModifiedFieldType hsel mods) a baseType signType) => Data.SignTyped.Class.GSignableRep mods s (GHC.Generics.S1 ('GHC.Generics.MetaSel ('GHC.Maybe.Just hsel) mssu msss msds) (GHC.Generics.K1 i a))
instance Data.SignTyped.Class.SignableValueDefault baseType a2 => Data.SignTyped.Class.SelectedFieldSignType 'GHC.Maybe.Nothing a2 baseType a2
instance (GHC.Types.Coercible a s, Data.SignTyped.Class.SignableValueDefault baseType s) => Data.SignTyped.Class.SelectedFieldSignType ('GHC.Maybe.Just s) a baseType s
instance GHC.TypeLits.KnownSymbol ethName => Data.SignTyped.Class.SelectedFieldName 'GHC.Maybe.Nothing ethName ethName
instance forall k (ethName :: GHC.Types.Symbol) (hsel :: k). GHC.TypeLits.KnownSymbol ethName => Data.SignTyped.Class.SelectedFieldName ('GHC.Maybe.Just ethName) hsel ethName
instance Data.SignTyped.Class.GSignableRep mods s g => Data.SignTyped.Class.GSignableRep mods s (GHC.Generics.D1 md g)
instance Data.SignTyped.Class.GSignableRep mods s g => Data.SignTyped.Class.GSignableRep mods s (GHC.Generics.C1 mc g)
instance (Data.SignTyped.Class.GSignableRep mods s ga, Data.SignTyped.Class.GSignableRep mods s gb) => Data.SignTyped.Class.GSignableRep mods s (ga GHC.Generics.:*: gb)
instance Data.SignTyped.Class.SignableValue baseType a => Data.SignTyped.Class.SignableValueDefault baseType (Data.SignTyped.Class.AsBaseType baseType a)
instance (GHC.TypeNats.KnownNat arrSize, Data.SignTyped.Class.SignableValueDefault baseType a) => Data.SignTyped.Class.SignableValueDefault baseType (Data.SignTyped.Class.AsSized arrSize a)
instance (GHC.TypeNats.KnownNat arrSize, Data.SignTyped.Class.SignableValue baseType a) => Data.SignTyped.Class.SignableValue baseType (Data.SignTyped.Class.AsSized arrSize a)
instance Data.SignTyped.Class.SignableValue baseType a => Data.SignTyped.Class.SignableValue baseType [a]
instance Data.SignTyped.Class.SignableValue "bool" GHC.Types.Bool
instance Data.Functor.Contravariant.Contravariant Data.SignTyped.Class.SignableValueHandle
instance GHC.Base.Applicative (Data.SignTyped.Class.Embed ctx)
instance GHC.Base.Monad (Data.SignTyped.Class.Embed ctx)
instance Control.Monad.Fail.MonadFail (Data.SignTyped.Class.Embed ctx)

module Data.SignTyped.EIP712Domain

-- | To avoid typos, use this constant for the canonical name of the domain
--   struct, instead of typing the literal directly.
type EIP712DomainSymbol = "EIP712Domain"

-- | The domain structure, from which the domain separator is derived.
--   
--   The parameter configures the presence and Haskell representation of
--   its fields.
--   
--   The equality constraint is there to guide the type inference.
data EIP712Domain (opt :: EIP712DomainStructure)
EIP712Domain :: FMaybe (EIP712DomainStructureNameType opt) -> FMaybe (EIP712DomainStructureVersionType opt) -> FMaybe (EIP712DomainStructureChainIdType opt) -> FMaybe (EIP712DomainStructureVerifyingContractType opt) -> FMaybe (EIP712DomainStructureSaltType opt) -> EIP712Domain (opt :: EIP712DomainStructure)
[eip712DomainName] :: EIP712Domain (opt :: EIP712DomainStructure) -> FMaybe (EIP712DomainStructureNameType opt)
[eip712DomainVersion] :: EIP712Domain (opt :: EIP712DomainStructure) -> FMaybe (EIP712DomainStructureVersionType opt)
[eip712DomainChainId] :: EIP712Domain (opt :: EIP712DomainStructure) -> FMaybe (EIP712DomainStructureChainIdType opt)
[eip712DomainVerifyingContract] :: EIP712Domain (opt :: EIP712DomainStructure) -> FMaybe (EIP712DomainStructureVerifyingContractType opt)
[eip712DomainSalt] :: EIP712Domain (opt :: EIP712DomainStructure) -> FMaybe (EIP712DomainStructureSaltType opt)

-- | A wrapper that combines a <a>EIP712Domain</a> with its
--   <a>KnownEIP712DomainStructure</a> instance.
data SomeEIP712Domain
SomeEIP712Domain :: EIP712Domain opt -> SomeEIP712Domain

-- | In the EIP-712 spec, the fields of the <tt>EIP712Domain</tt> struct
--   are optional. If some fields are not necessary in a specific case,
--   they can be removed from the type definition entirely. Since we set up
--   the <a>SignableValue</a> machinery to have struct definitions depend
--   only on Haskell types, not values, that means each possible
--   configuration of the domain fields must be a separate Haskell type.
--   This structure is the type-level parameter that distinguishes between
--   these configurations.
--   
--   In addition, we allow the Haskell representation of each field to be
--   any Haskell type that has a <a>SignableValue</a> instance for the
--   appropriate Solidity typename.
data EIP712DomainStructure
EIP712DomainStructure :: Maybe Type -> Maybe Type -> Maybe Type -> Maybe Type -> Maybe Type -> EIP712DomainStructure
[eip712DomainStructureNameType] :: EIP712DomainStructure -> Maybe Type
[eip712DomainStructureVersionType] :: EIP712DomainStructure -> Maybe Type
[eip712DomainStructureChainIdType] :: EIP712DomainStructure -> Maybe Type
[eip712DomainStructureVerifyingContractType] :: EIP712DomainStructure -> Maybe Type
[eip712DomainStructureSaltType] :: EIP712DomainStructure -> Maybe Type
type family EIP712DomainStructureNameType opt
type family EIP712DomainStructureVersionType opt
type family EIP712DomainStructureChainIdType opt
type family EIP712DomainStructureVerifyingContractType opt
type family EIP712DomainStructureSaltType opt

-- | This typeclass is a "reified type synonym" for its context. Unlike a
--   normal type synonym, however, this name can also be used partially
--   applied, for example, as a parameter to <a>KnownCMaybe</a>.
class (KnownCMaybe (SignableValue "string") (EIP712DomainStructureNameType opt), KnownCMaybe (SignableValue "string") (EIP712DomainStructureVersionType opt), KnownCMaybe (SignableValue "uint256") (EIP712DomainStructureChainIdType opt), KnownCMaybe (SignableValue "address") (EIP712DomainStructureVerifyingContractType opt), KnownCMaybe (SignableValue "bytes32") (EIP712DomainStructureSaltType opt), KnownCMaybe Show (EIP712DomainStructureNameType opt), KnownCMaybe Show (EIP712DomainStructureVersionType opt), KnownCMaybe Show (EIP712DomainStructureChainIdType opt), KnownCMaybe Show (EIP712DomainStructureVerifyingContractType opt), KnownCMaybe Show (EIP712DomainStructureSaltType opt)) => KnownEIP712DomainStructure opt

-- | The canonical <a>EthType</a> for <tt>EIP712Domain</tt>.
eip712DomainEthType :: EthType ('EthReprStruct EIP712DomainSymbol)

-- | The type family for a conditionally present value.
data family FMaybe (m :: Maybe Type) :: Type
instance Data.SignTyped.EIP712Domain.KnownEIP712DomainStructure opt => GHC.Show.Show (Data.SignTyped.EIP712Domain.EIP712Domain opt)
instance Data.SignTyped.EIP712Domain.KnownEIP712DomainStructure opt => Data.SignTyped.Class.SignableValue Data.SignTyped.EIP712Domain.EIP712DomainSymbol (Data.SignTyped.EIP712Domain.EIP712Domain opt)
instance Data.SignTyped.EIP712Domain.KnownEIP712DomainStructure opt => Data.SignTyped.Class.SignableValueDefault Data.SignTyped.EIP712Domain.EIP712DomainSymbol (Data.SignTyped.EIP712Domain.EIP712Domain opt)
instance (Data.SignTyped.Type.SCMaybe.KnownCMaybe (Data.SignTyped.Class.SignableValue "string") (Data.SignTyped.EIP712Domain.EIP712DomainStructureNameType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe (Data.SignTyped.Class.SignableValue "string") (Data.SignTyped.EIP712Domain.EIP712DomainStructureVersionType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe (Data.SignTyped.Class.SignableValue "uint256") (Data.SignTyped.EIP712Domain.EIP712DomainStructureChainIdType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe (Data.SignTyped.Class.SignableValue "address") (Data.SignTyped.EIP712Domain.EIP712DomainStructureVerifyingContractType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe (Data.SignTyped.Class.SignableValue "bytes32") (Data.SignTyped.EIP712Domain.EIP712DomainStructureSaltType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe GHC.Show.Show (Data.SignTyped.EIP712Domain.EIP712DomainStructureNameType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe GHC.Show.Show (Data.SignTyped.EIP712Domain.EIP712DomainStructureVersionType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe GHC.Show.Show (Data.SignTyped.EIP712Domain.EIP712DomainStructureChainIdType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe GHC.Show.Show (Data.SignTyped.EIP712Domain.EIP712DomainStructureVerifyingContractType opt), Data.SignTyped.Type.SCMaybe.KnownCMaybe GHC.Show.Show (Data.SignTyped.EIP712Domain.EIP712DomainStructureSaltType opt)) => Data.SignTyped.EIP712Domain.KnownEIP712DomainStructure opt

module Data.SignTyped.Message

-- | A data structure that combines the message to sign, its domain and
--   their type information.
--   
--   It corresponds directly to the <tt>TypedData</tt> parameter of the
--   <tt>eth_signTypedData</tt> request, and its JSON instances map
--   directly to that.
--   
--   As an emergent generalization, this structure allows the signable
--   object to be any Solidity type with a defined <tt>encodeData</tt>, not
--   just structs. This includes atomic types (such as <tt>uint256</tt> and
--   <tt>bytes</tt>) and arrays (e.g. <tt>bytes[4][]</tt>).
data Message
Message :: TypeContext ctx -> EthValue ctx ('EthReprStruct EIP712DomainSymbol) -> EthType primRep -> EthValue ctx primRep -> Message
[messageTypeContext] :: Message -> TypeContext ctx
[messageDomainValue] :: Message -> EthValue ctx ('EthReprStruct EIP712DomainSymbol)
[messagePrimaryType] :: Message -> EthType primRep
[messagePrimaryValue] :: Message -> EthValue ctx primRep

-- | Given a domain and a signable object, encode them into a
--   <a>Message</a>.
--   
--   This function uses a <a>SignableValueDefault</a> instance to define
--   the exact encoding. To choose a different encoding, use
--   <a>makeMessageWith</a>.
makeMessage :: forall a ethType. SignableValueDefault ethType a => SomeEIP712Domain -> a -> Either String Message

-- | Given a domain and a signable object, encode them into a
--   <a>Message</a>.
--   
--   This function uses an explicitly given <a>SignableValueHandle</a> to
--   define the exact encoding. To use the default encoding for the given
--   type, you can use <a>makeMessage</a> instead.
makeMessageWith :: forall a. SignableValueHandle a -> SomeEIP712Domain -> a -> Either String Message

-- | Retrieve the chainId from the message's domain, if present.
messageChainId :: Message -> Maybe Int

-- | Calculates the final hash of the message, as given by the expression:
--   
--   <pre>
--   keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message))
--   
--   </pre>
hashMessage :: Message -> MessageHash

-- | Sign a message with the given secret key.
signMessage :: Ctx -> SecKey -> Message -> Signature

-- | Recovers the signer's address from a message and a signature.
recoverMessageSigner :: Ctx -> Message -> Signature -> Maybe Address
instance GHC.Show.Show Data.SignTyped.Message.Message
instance GHC.Classes.Eq Data.SignTyped.Message.Message
instance Data.Aeson.Types.ToJSON.ToJSON Data.SignTyped.Message.Message
instance Data.Aeson.Types.FromJSON.FromJSON Data.SignTyped.Message.Message
