-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/fullstack-development/reducible#readme</a>
@package reducible
@version 0.1.0.20220514

module Control.Reducible.Lifting

-- | This function plays the role of <a>lift</a> for <tt><a>Lifting</a>
--   m</tt>.
--   
--   The reason we don't use <a>lift</a> proper is that the exact
--   implementation depends on both parameters <tt>m</tt> and <tt>n</tt>,
--   but the kind of <a>MonadTrans</a> does not allow us that choice.
applyLifting :: MonadLifting m n => n a -> Lifting m n a

-- | A wrapper for decomposing monad transformer applications.
--   
--   <tt><a>Lifting</a> m n</tt> can be seen as an application of an opaque
--   monad transformer <tt><a>Lifting</a> m</tt> to a monad <tt>n</tt>.
--   
--   Normally, you wouldn't use <a>Lifting</a> in you business code. When
--   generalizing a monad with <a>Reducible</a>, <tt><a>Lifting</a> m
--   n</tt> is used as the the most general representation.
newtype Lifting (m :: Type -> Type) (n :: Type -> Type) a
Lifting :: m a -> Lifting (m :: Type -> Type) (n :: Type -> Type) a
[unwrapLifting] :: Lifting (m :: Type -> Type) (n :: Type -> Type) a -> m a

-- | Lifting of actions in monad <tt>n</tt> into <tt>m</tt>,
--   
--   Whereas <a>MonadTrans</a> provides lifting by exactly one transformer
--   layer at a time, <a>MonadLifting</a> can lift by an arbitrary distance
--   at once.
class MonadLifting m n
liftLong :: MonadLifting m n => n a -> m a
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Reducible.Lifting.Lifting m n)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Reducible.Lifting.Lifting m n)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Reducible.Lifting.Lifting m n)
instance Control.Reducible.Lifting.MonadLifting m m
instance (Control.Monad.Trans.Class.MonadTrans t, Control.Reducible.Lifting.MonadLifting m n, GHC.Base.Monad m) => Control.Reducible.Lifting.MonadLifting (t m) n
instance (Control.Reducible.Lifting.MonadLifting m n, GHC.Base.Monad m, Control.Monad.Fail.MonadFail n) => Control.Monad.Fail.MonadFail (Control.Reducible.Lifting.Lifting m n)
instance (Control.Reducible.Lifting.MonadLifting m n, GHC.Base.Monad m, Control.Monad.Catch.MonadThrow n) => Control.Monad.Catch.MonadThrow (Control.Reducible.Lifting.Lifting m n)
instance (Control.Reducible.Lifting.MonadLifting m n, GHC.Base.Monad m, Control.Monad.State.Class.MonadState s n) => Control.Monad.State.Class.MonadState s (Control.Reducible.Lifting.Lifting m n)

module Control.Reducible

-- | An instance of <tt><a>Reducible</a> m</tt> means that <tt>m</tt> is a
--   special case of another monad <tt><a>Reduced</a> m</tt>; for example,
--   <a>WriterT</a> is a special case of a <a>StateT</a>.
--   
--   In a degenerate case, <tt>m</tt> and <tt><a>Reduced</a> m</tt> may be
--   isomorphic; such as <tt><a>MaybeT</a> m</tt> and <tt><a>ExceptT</a> ()
--   m</tt>.
--   
--   The laws:
--   
--   <ol>
--   <li>Generalization is invertible:<pre>fromReduced . toReduced ===
--   id</pre>The reverse is not required to hold: as the generalized form
--   is usually a stronger monad than the original one. For example, we
--   generalize <a>WriterT</a> to <a>StateT</a>, since the Writer monad can
--   be correctly emulated by the State; but not the other way around,Thus,
--   we require that transforming <tt><a>WriterT</a> -&gt; <a>StateT</a>
--   -&gt; <a>WriterT</a></tt> results in exactly the same behavior as in
--   the original monadic action; however, doing the same with
--   <tt><a>StateT</a> -&gt; <a>WriterT</a> -&gt; <a>StateT</a></tt> is
--   plainly impossible â€“ so, we require <tt>fromReduced . toReduced ===
--   id</tt>, but give no laws for <tt>toReduced . fromReduced</tt>.</li>
--   <li><a>pure</a> and <a>(&gt;&gt;=)</a> of the generalized form must
--   match the original:<pre>toReduced . pure = pure</pre><pre>fromReduced
--   (toReduced m &gt;&gt;= toReduced . f) === m &gt;&gt;= f</pre>Again,
--   the reverse may not hold in general: the generalized form may contain
--   additional context, that the binding operator of the original does not
--   account for. For example, <a>StateT</a> expects to see the effects of
--   all previous actions in the state on input, but <a>WriterT</a> doesn't
--   give any means to implement that.</li>
--   </ol>
--   
--   The default implementation is to <a>coerce</a> between the given monad
--   and its reduced form.
class Reducible (m :: Type -> Type) where {
    type family Reduced m :: Type -> Type;
}
fromReduced :: Reducible m => Reduced m a -> m a
fromReduced :: (Reducible m, Coercible (Reduced m a) (m a)) => Reduced m a -> m a
toReduced :: Reducible m => m a -> Reduced m a
toReduced :: (Reducible m, Coercible (m a) (Reduced m a)) => m a -> Reduced m a

-- | This function plays the role of <a>lift</a> for <tt><a>Lifting</a>
--   m</tt>.
--   
--   The reason we don't use <a>lift</a> proper is that the exact
--   implementation depends on both parameters <tt>m</tt> and <tt>n</tt>,
--   but the kind of <a>MonadTrans</a> does not allow us that choice.
applyLifting :: MonadLifting m n => n a -> Lifting m n a

-- | A wrapper for decomposing monad transformer applications.
--   
--   <tt><a>Lifting</a> m n</tt> can be seen as an application of an opaque
--   monad transformer <tt><a>Lifting</a> m</tt> to a monad <tt>n</tt>.
--   
--   Normally, you wouldn't use <a>Lifting</a> in you business code. When
--   generalizing a monad with <a>Reducible</a>, <tt><a>Lifting</a> m
--   n</tt> is used as the the most general representation.
newtype Lifting (m :: Type -> Type) (n :: Type -> Type) a
Lifting :: m a -> Lifting (m :: Type -> Type) (n :: Type -> Type) a
[unwrapLifting] :: Lifting (m :: Type -> Type) (n :: Type -> Type) a -> m a

-- | Lifting of actions in monad <tt>n</tt> into <tt>m</tt>,
--   
--   Whereas <a>MonadTrans</a> provides lifting by exactly one transformer
--   layer at a time, <a>MonadLifting</a> can lift by an arbitrary distance
--   at once.
class MonadLifting m n
liftLong :: MonadLifting m n => n a -> m a
instance GHC.Base.Functor m => Control.Reducible.Reducible (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (GHC.Base.Functor m, GHC.Base.Monoid w) => Control.Reducible.Reducible (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Functor m, GHC.Base.Monoid w) => Control.Reducible.Reducible (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance (GHC.Base.Functor m, GHC.Base.Monoid w) => Control.Reducible.Reducible (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Control.Reducible.Reducible (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Control.Reducible.Reducible ((,) w)
instance Control.Reducible.Reducible ((,,) w1 w2)
instance Control.Reducible.Reducible ((,,,) w1 w2 w3)
instance Control.Reducible.Reducible (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Reducible.Reducible (Data.Either.Either e)
instance GHC.Base.Functor m => Control.Reducible.Reducible (Control.Monad.Trans.Maybe.MaybeT m)
instance Control.Reducible.Reducible GHC.Maybe.Maybe
instance Control.Reducible.Reducible (Control.Monad.Catch.Pure.CatchT m)
instance Control.Reducible.Reducible (Control.Monad.Trans.Cont.ContT q m)
instance Control.Reducible.Reducible (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (GHC.Base.Functor m, GHC.Base.Monoid w) => Control.Reducible.Reducible (Control.Monad.Trans.Accum.AccumT w m)
instance Control.Reducible.Reducible (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Reducible.Reducible (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Reducible.Reducible ((->) r)
instance Control.Reducible.Reducible (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Reducible.Reducible (Control.Monad.Trans.State.Strict.StateT s m)


-- | This module contains the orphan instances for some typeclasses that
--   enable them to use <a>Reducible</a> as a fallback,
module Control.Reducible.Orphans
instance (Control.Reducible.Reducible m, GHC.Base.Applicative m, GHC.Base.Alternative (Control.Reducible.Reduced m)) => GHC.Base.Alternative m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, GHC.Base.MonadPlus (Control.Reducible.Reduced m)) => GHC.Base.MonadPlus m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Fail.MonadFail (Control.Reducible.Reduced m)) => Control.Monad.Fail.MonadFail m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Fix.MonadFix (Control.Reducible.Reduced m)) => Control.Monad.Fix.MonadFix m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Catch.MonadThrow (Control.Reducible.Reduced m)) => Control.Monad.Catch.MonadThrow m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Catch.MonadCatch (Control.Reducible.Reduced m)) => Control.Monad.Catch.MonadCatch m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Catch.MonadMask (Control.Reducible.Reduced m)) => Control.Monad.Catch.MonadMask m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Error.Class.MonadError e (Control.Reducible.Reduced m)) => Control.Monad.Error.Class.MonadError e m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.Reader.Class.MonadReader r (Control.Reducible.Reduced m)) => Control.Monad.Reader.Class.MonadReader r m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, Control.Monad.State.Class.MonadState s (Control.Reducible.Reduced m)) => Control.Monad.State.Class.MonadState s m
instance (Control.Reducible.Reducible m, GHC.Base.Monad m, GHC.Base.Monoid w, Control.Monad.Writer.Class.MonadWriter w (Control.Reducible.Reduced m)) => Control.Monad.Writer.Class.MonadWriter w m
