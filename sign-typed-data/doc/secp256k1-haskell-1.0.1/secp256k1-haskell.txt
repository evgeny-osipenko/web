-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings for secp256k1
--   
--   Sign and verify signatures using the secp256k1 library.
@package secp256k1-haskell
@version 1.0.1


-- | The API for this module may change at any time. This is an internal
--   module only exposed for hacking and experimentation.
module Crypto.Secp256k1.Internal.ForeignTypes
data LCtx
data PubKey64
data Msg32
data Sig64
data Seed32
data Compact64
data SecKey32
data Tweak32
data RecSig65
type CtxFlags = CUInt
type SerFlags = CUInt
type Ret = CInt
type NonceFun a = Ptr CUChar -> Ptr CUChar -> Ptr CUChar -> Ptr CUChar -> Ptr a -> CInt -> IO CInt
compressed :: SerFlags
uncompressed :: SerFlags
isSuccess :: Ret -> Bool


-- | The API for this module may change at any time. This is an internal
--   module only exposed for hacking and experimentation.
module Crypto.Secp256k1.Internal.BaseOps
ecPubKeyParse :: Ptr LCtx -> Ptr PubKey64 -> Ptr CUChar -> CSize -> IO Ret
ecPubKeySerialize :: Ptr LCtx -> Ptr CUChar -> Ptr CSize -> Ptr PubKey64 -> SerFlags -> IO Ret
ecdsaSignatureParseCompact :: Ptr LCtx -> Ptr Sig64 -> Ptr Compact64 -> IO Ret
ecdsaSignatureParseDer :: Ptr LCtx -> Ptr Sig64 -> Ptr CUChar -> CSize -> IO Ret
ecdsaSignatureSerializeDer :: Ptr LCtx -> Ptr CUChar -> Ptr CSize -> Ptr Sig64 -> IO Ret
ecdsaSignatureSerializeCompact :: Ptr LCtx -> Ptr Compact64 -> Ptr Sig64 -> IO Ret
ecdsaVerify :: Ptr LCtx -> Ptr Sig64 -> Ptr Msg32 -> Ptr PubKey64 -> IO Ret
ecdsaSignatureNormalize :: Ptr LCtx -> Ptr Sig64 -> Ptr Sig64 -> IO Ret
ecdsaSign :: Ptr LCtx -> Ptr Sig64 -> Ptr Msg32 -> Ptr SecKey32 -> FunPtr (NonceFun a) -> Ptr a -> IO Ret
ecSecKeyVerify :: Ptr LCtx -> Ptr SecKey32 -> IO Ret
ecPubKeyCreate :: Ptr LCtx -> Ptr PubKey64 -> Ptr SecKey32 -> IO Ret
ecSecKeyTweakAdd :: Ptr LCtx -> Ptr SecKey32 -> Ptr Tweak32 -> IO Ret
ecTweakNegate :: Ptr LCtx -> Ptr Tweak32 -> IO Ret
ecPubKeyTweakAdd :: Ptr LCtx -> Ptr PubKey64 -> Ptr Tweak32 -> IO Ret
ecSecKeyTweakMul :: Ptr LCtx -> Ptr SecKey32 -> Ptr Tweak32 -> IO Ret
ecPubKeyTweakMul :: Ptr LCtx -> Ptr PubKey64 -> Ptr Tweak32 -> IO Ret
ecPubKeyCombine :: Ptr LCtx -> Ptr PubKey64 -> Ptr (Ptr PubKey64) -> CInt -> IO Ret


-- | The API for this module may change at any time. This is an internal
--   module only exposed for hacking and experimentation.
module Crypto.Secp256k1.Internal.Util
decodeHex :: ConvertibleStrings a ByteString => a -> Maybe ByteString
showsHex :: ByteString -> ShowS
unsafeUseByteString :: ByteString -> ((Ptr a, CSize) -> IO b) -> IO b
useByteString :: ByteString -> ((Ptr a, CSize) -> IO b) -> IO b
unsafePackByteString :: (Ptr a, CSize) -> IO ByteString
packByteString :: (Ptr a, CSize) -> IO ByteString
withRandomSeed :: (Ptr Seed32 -> IO a) -> IO a


-- | The API for this module may change at any time. This is an internal
--   module only exposed for hacking and experimentation.
module Crypto.Secp256k1.Internal.Context
newtype Ctx
Ctx :: Ptr LCtx -> Ctx
[$sel:get:Ctx] :: Ctx -> Ptr LCtx
randomizeContext :: Ctx -> IO ()
createContext :: IO Ctx
cloneContext :: Ctx -> IO Ctx
destroyContext :: Ctx -> IO ()
withContext :: (Ctx -> IO a) -> IO a
verify :: CtxFlags
sign :: CtxFlags
signVerify :: CtxFlags
contextCreate :: CtxFlags -> IO (Ptr LCtx)
contextClone :: Ptr LCtx -> IO (Ptr LCtx)
contextDestroy :: Ptr LCtx -> IO ()
setIllegalCallback :: Ptr LCtx -> FunPtr (CString -> Ptr a -> IO ()) -> Ptr a -> IO ()
setErrorCallback :: Ptr LCtx -> FunPtr (CString -> Ptr a -> IO ()) -> Ptr a -> IO ()
contextRandomize :: Ptr LCtx -> Ptr Seed32 -> IO Ret


-- | Crytpographic functions from Bitcoin’s secp256k1 library.
--   
--   The API for this module may change at any time. This is an internal
--   module only exposed for hacking and experimentation.
module Crypto.Secp256k1.Internal.Base
newtype PubKey
PubKey :: ByteString -> PubKey
[$sel:get:PubKey] :: PubKey -> ByteString
newtype Msg
Msg :: ByteString -> Msg
[$sel:get:Msg] :: Msg -> ByteString
newtype Sig
Sig :: ByteString -> Sig
[$sel:get:Sig] :: Sig -> ByteString
newtype SecKey
SecKey :: ByteString -> SecKey
[$sel:get:SecKey] :: SecKey -> ByteString
newtype Tweak
Tweak :: ByteString -> Tweak
[$sel:get:Tweak] :: Tweak -> ByteString
newtype CompactSig
CompactSig :: ByteString -> CompactSig
[$sel:get:CompactSig] :: CompactSig -> ByteString

-- | Import 64-byte <a>ByteString</a> as <a>Sig</a>.
sig :: ByteString -> Maybe Sig

-- | Import 64-byte <a>ByteString</a> as <a>PubKey</a>.
pubKey :: ByteString -> Maybe PubKey

-- | Import 32-byte <a>ByteString</a> as <a>Msg</a>.
msg :: ByteString -> Maybe Msg

-- | Import 32-byte <a>ByteString</a> as <a>SecKey</a>.
secKey :: ByteString -> Maybe SecKey
compactSig :: ByteString -> Maybe CompactSig

-- | Convert signature to a normalized lower-S form. <a>Nothing</a>
--   indicates that it was already normal.
normalizeSig :: Ctx -> Sig -> Maybe Sig

-- | 32-Byte <a>ByteString</a> as <a>Tweak</a>.
tweak :: ByteString -> Maybe Tweak

-- | Import DER-encoded public key.
importPubKey :: Ctx -> ByteString -> Maybe PubKey

-- | Encode public key as DER. First argument <a>True</a> for compressed
--   output.
exportPubKey :: Ctx -> Bool -> PubKey -> ByteString
exportCompactSig :: Ctx -> Sig -> CompactSig
importCompactSig :: Ctx -> CompactSig -> Maybe Sig

-- | Import DER-encoded signature.
importSig :: Ctx -> ByteString -> Maybe Sig

-- | Encode signature as strict DER.
exportSig :: Ctx -> Sig -> ByteString

-- | Verify message signature. <a>True</a> means that the signature is
--   correct.
verifySig :: Ctx -> PubKey -> Sig -> Msg -> Bool
signMsg :: Ctx -> SecKey -> Msg -> Sig
derivePubKey :: Ctx -> SecKey -> PubKey

-- | Add tweak to secret key.
tweakAddSecKey :: Ctx -> SecKey -> Tweak -> Maybe SecKey

-- | Multiply secret key by tweak.
tweakMulSecKey :: Ctx -> SecKey -> Tweak -> Maybe SecKey

-- | Add tweak to public key. Tweak is multiplied first by G to obtain a
--   point.
tweakAddPubKey :: Ctx -> PubKey -> Tweak -> Maybe PubKey

-- | Multiply public key by tweak. Tweak is multiplied first by G to obtain
--   a point.
tweakMulPubKey :: Ctx -> PubKey -> Tweak -> Maybe PubKey

-- | Add multiple public keys together.
combinePubKeys :: Ctx -> [PubKey] -> Maybe PubKey
tweakNegate :: Ctx -> Tweak -> Maybe Tweak
instance Control.DeepSeq.NFData Crypto.Secp256k1.Internal.Base.PubKey
instance Data.Hashable.Class.Hashable Crypto.Secp256k1.Internal.Base.PubKey
instance GHC.Generics.Generic Crypto.Secp256k1.Internal.Base.PubKey
instance GHC.Classes.Eq Crypto.Secp256k1.Internal.Base.PubKey
instance Control.DeepSeq.NFData Crypto.Secp256k1.Internal.Base.Msg
instance Data.Hashable.Class.Hashable Crypto.Secp256k1.Internal.Base.Msg
instance GHC.Generics.Generic Crypto.Secp256k1.Internal.Base.Msg
instance GHC.Classes.Eq Crypto.Secp256k1.Internal.Base.Msg
instance Control.DeepSeq.NFData Crypto.Secp256k1.Internal.Base.Sig
instance Data.Hashable.Class.Hashable Crypto.Secp256k1.Internal.Base.Sig
instance GHC.Generics.Generic Crypto.Secp256k1.Internal.Base.Sig
instance GHC.Classes.Eq Crypto.Secp256k1.Internal.Base.Sig
instance Control.DeepSeq.NFData Crypto.Secp256k1.Internal.Base.SecKey
instance Data.Hashable.Class.Hashable Crypto.Secp256k1.Internal.Base.SecKey
instance GHC.Generics.Generic Crypto.Secp256k1.Internal.Base.SecKey
instance GHC.Classes.Eq Crypto.Secp256k1.Internal.Base.SecKey
instance Control.DeepSeq.NFData Crypto.Secp256k1.Internal.Base.Tweak
instance Data.Hashable.Class.Hashable Crypto.Secp256k1.Internal.Base.Tweak
instance GHC.Generics.Generic Crypto.Secp256k1.Internal.Base.Tweak
instance GHC.Classes.Eq Crypto.Secp256k1.Internal.Base.Tweak
instance Control.DeepSeq.NFData Crypto.Secp256k1.Internal.Base.CompactSig
instance Data.Hashable.Class.Hashable Crypto.Secp256k1.Internal.Base.CompactSig
instance GHC.Generics.Generic Crypto.Secp256k1.Internal.Base.CompactSig
instance GHC.Classes.Eq Crypto.Secp256k1.Internal.Base.CompactSig
instance GHC.Read.Read Crypto.Secp256k1.Internal.Base.Tweak
instance Data.String.IsString Crypto.Secp256k1.Internal.Base.Tweak
instance GHC.Show.Show Crypto.Secp256k1.Internal.Base.Tweak
instance GHC.Read.Read Crypto.Secp256k1.Internal.Base.SecKey
instance Data.String.IsString Crypto.Secp256k1.Internal.Base.SecKey
instance GHC.Show.Show Crypto.Secp256k1.Internal.Base.SecKey
instance Test.QuickCheck.Arbitrary.Arbitrary Crypto.Secp256k1.Internal.Base.SecKey
instance GHC.Read.Read Crypto.Secp256k1.Internal.Base.Sig
instance Data.String.IsString Crypto.Secp256k1.Internal.Base.Sig
instance GHC.Show.Show Crypto.Secp256k1.Internal.Base.Sig
instance GHC.Read.Read Crypto.Secp256k1.Internal.Base.Msg
instance Data.String.IsString Crypto.Secp256k1.Internal.Base.Msg
instance GHC.Show.Show Crypto.Secp256k1.Internal.Base.Msg
instance Test.QuickCheck.Arbitrary.Arbitrary Crypto.Secp256k1.Internal.Base.Msg
instance GHC.Read.Read Crypto.Secp256k1.Internal.Base.PubKey
instance Data.String.IsString Crypto.Secp256k1.Internal.Base.PubKey
instance GHC.Show.Show Crypto.Secp256k1.Internal.Base.PubKey


-- | Crytpographic functions from Bitcoin’s secp256k1 library.
module Crypto.Secp256k1
newtype Ctx
Ctx :: Ptr LCtx -> Ctx
[$sel:get:Ctx] :: Ctx -> Ptr LCtx
withContext :: (Ctx -> IO a) -> IO a
randomizeContext :: Ctx -> IO ()
createContext :: IO Ctx
cloneContext :: Ctx -> IO Ctx
destroyContext :: Ctx -> IO ()
newtype Msg
Msg :: ByteString -> Msg
[$sel:get:Msg] :: Msg -> ByteString

-- | Import 32-byte <a>ByteString</a> as <a>Msg</a>.
msg :: ByteString -> Maybe Msg
newtype SecKey
SecKey :: ByteString -> SecKey
[$sel:get:SecKey] :: SecKey -> ByteString

-- | Import 32-byte <a>ByteString</a> as <a>SecKey</a>.
secKey :: ByteString -> Maybe SecKey
derivePubKey :: Ctx -> SecKey -> PubKey
newtype PubKey
PubKey :: ByteString -> PubKey
[$sel:get:PubKey] :: PubKey -> ByteString

-- | Import 64-byte <a>ByteString</a> as <a>PubKey</a>.
pubKey :: ByteString -> Maybe PubKey

-- | Import DER-encoded public key.
importPubKey :: Ctx -> ByteString -> Maybe PubKey

-- | Encode public key as DER. First argument <a>True</a> for compressed
--   output.
exportPubKey :: Ctx -> Bool -> PubKey -> ByteString
newtype Sig
Sig :: ByteString -> Sig
[$sel:get:Sig] :: Sig -> ByteString

-- | Import 64-byte <a>ByteString</a> as <a>Sig</a>.
sig :: ByteString -> Maybe Sig
signMsg :: Ctx -> SecKey -> Msg -> Sig

-- | Verify message signature. <a>True</a> means that the signature is
--   correct.
verifySig :: Ctx -> PubKey -> Sig -> Msg -> Bool

-- | Convert signature to a normalized lower-S form. <a>Nothing</a>
--   indicates that it was already normal.
normalizeSig :: Ctx -> Sig -> Maybe Sig

-- | Import DER-encoded signature.
importSig :: Ctx -> ByteString -> Maybe Sig

-- | Encode signature as strict DER.
exportSig :: Ctx -> Sig -> ByteString
newtype CompactSig
CompactSig :: ByteString -> CompactSig
[$sel:get:CompactSig] :: CompactSig -> ByteString
compactSig :: ByteString -> Maybe CompactSig
exportCompactSig :: Ctx -> Sig -> CompactSig
importCompactSig :: Ctx -> CompactSig -> Maybe Sig
newtype Tweak
Tweak :: ByteString -> Tweak
[$sel:get:Tweak] :: Tweak -> ByteString

-- | 32-Byte <a>ByteString</a> as <a>Tweak</a>.
tweak :: ByteString -> Maybe Tweak

-- | Add tweak to secret key.
tweakAddSecKey :: Ctx -> SecKey -> Tweak -> Maybe SecKey

-- | Multiply secret key by tweak.
tweakMulSecKey :: Ctx -> SecKey -> Tweak -> Maybe SecKey

-- | Add tweak to public key. Tweak is multiplied first by G to obtain a
--   point.
tweakAddPubKey :: Ctx -> PubKey -> Tweak -> Maybe PubKey

-- | Multiply public key by tweak. Tweak is multiplied first by G to obtain
--   a point.
tweakMulPubKey :: Ctx -> PubKey -> Tweak -> Maybe PubKey

-- | Add multiple public keys together.
combinePubKeys :: Ctx -> [PubKey] -> Maybe PubKey
tweakNegate :: Ctx -> Tweak -> Maybe Tweak

module Paths_secp256k1_haskell
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath
